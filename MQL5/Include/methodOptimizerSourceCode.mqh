//+------------------------------------------------------------------+
//|                                    methodOptimizerSourceCode.mqh |
//|                                  Copyright 2021, Michal Machacek |
//|                                 https://www.github.com/mmachacek |
//+------------------------------------------------------------------+
#property copyright "Copyright 2021, Michal Machacek"
#property link      "https://www.github.com/mmachacek"

string firstPartCode =
"//+------------------------------------------------------------------+\n"
"//|                                              MethodOptimizer.mq5 |\n"
"//|                                  Copyright 2021, Michal Machacek |\n"
"//|                                     https://github.com/mmachacek |\n"
"//+------------------------------------------------------------------+\n"
"\n"
"#property copyright \"Copyright 2021, Michal Machacek\"\n"
"#property link      \"https://github.com/mmachacek\"\n"
"#property version   \"1.00\"\n"
"input string info0_2 = \"openPriceBacktest - Prevents missing active orders during the open price backtest/optimalization\";\n"
"input bool openPriceBacktest = false;\n"
"input string info0_3 = \"moveToBE = 0 - disabled; X > 0 & X < 0.9 - Move to the breakeven when the price is close to the takeprofit by ex. X = 0.2 - 20% before takeprofit\";\n"
"input double moveToBE = 0;\n"
"input double BETollerancePercentage = 0.05;\n"
"input string info0_4 = \"OrderProtection = If an order doesn't get into a profit after X candle(s) after opening a market order\";\n"
"input int orderProtection = 0;\n"
"input string info1 = \"marketOrdersOnly = false - Only pending orders (limit and stop orders); true - Only market orders (buy and sell orders)\";\n"
"input bool marketOrdersOnly = false;\n"
"input string info1_1 = \"entryOn(only for pending orders) = ex. 0.1 = 10% of candle\";\n"
"input double entryOn = 1.0;\n"
"input string info1_2 = \"stoplossOn = ex. 0.1 = 10% of candle\";\n"
"input double stoplossOn = 0.0;\n"
"input string info1_3 = \"takeprofiRatio = 0 - No Takeprofit; X > 0 - Takeprofit by ratio 1:X\";\n"
"input double takeprofitRatio = 1.0;\n"
"input string info1_4 = \"trailingStop = 0 - Disabled; 1 - Previous HIGH/LOW on an X candle (X = trailingStopCandleShift); 2 - Moving Average;\";\n"
"input int trailingStop = 0;\n"
"input string info1_4_1 = \"trailingStopOnlyInProfit = false - On every new candle; true - On a new candle only in profit\";\n"
"input bool trailingStopOnlyInProfit = false;\n"
"input int trailingStopCandleShift = 1;\n"
"input string info1_4_2_1 = \"TrailingStop MA - tsMAPeriod = MA Period; tsMAShift = MA Shift\";\n"
"input string info1_4_2_2 = \"tsMAMethod = MA Method (0-3); tsMAAppliedPrice = MA Applied Price (0-6), if(2-HIGH or 3-LOW both are used)\";\n"
"input string info1_4_2_3 = \"tsMACandleShift = MA Shift X Candles; tsMACandleShiftAfterOpen = Apply MA trailing stop after X candles from open\";\n"
"input int tsMAPeriod = 21;\n"
"input int tsMAShift = 0;\n"
"input int tsMAMethod = 0;\n"
"input int tsMAAppliedPrice = 0;\n"
"input int tsMACandleShift = 1;\n"
"input int tsMACandleShiftAfterOpen = 1;\n"
"input int startHour = 0;\n"
"input int endHour = 24;\n"
"input double Risk = 0.01;\n"
"input string info2 = \"Slippage - ex. 5 means 0.5 points slippage on a 5 digit pair, and 5 points on 4 digit pair\";\n"
"input int Slippage = 50;\n"
"input string info3 = \"brokerCommision - 8.5 = 0.85 Points; 0 = Disabled\";\n"
"input double brokerCommision = 5.5;\n"
"input bool entryWithSpread = true;\n"
"input int pendingExpirationShift = 1;\n"
"input int orderInQueueAttempts = 5;\n"
"input int orderInQueueSecondsDelay = 15;\n"
"input int EAMagicNumber = 5;\n"
"input bool bypassMaxLots = true;\n"
"input int bypassMaxLotsMagicNumber = 55;\n"
"input int bypassMaximumOrders = 100;\n"
"input string EAComment = \"\";\n"
"input bool closeOrdersBeforeMarketClose = false;\n"
"input bool closeOnlyLossOrdersBeforeMarketClose = false;\n"
"input bool closeOnlyProfitOrdersBeforeMarketClose = false;\n"
"input int marketCloseFridayHour = 20;\n"
"input int marketOpenHour = 1;\n"
"input bool preventOvernightTrading = false;\n"
"input bool closeOnlyOvernightLossOrders = false;\n"
"input bool closeOnlyOvernightProfitOrders = false;\n"
"input int preventOvernightTradingHour = 21;\n"
"input int enableAfterOvernightTradingHour = 1;\n"
"input string info12 = \"tradeDaysFrom = 0 - Sunday; 1 - Monday; 2 - Tuesday; 3 - Wednesday; 4 - Thursday; 5 - Friday; 6 - Saturday\";\n"
"input string info13 = \"tradeDaysTo = 0 - Sunday; 1 - Monday; 2 - Tuesday; 3 - Wednesday; 4 - Thursday; 5 - Friday; 6 - Saturday\";\n"
"input int tradeDaysFrom = 0;\n"
"input int tradeDaysTo = 6;\n"
"input string info4 = \"Alert, Email\";\n"
"input bool sendAlert = true;\n"
"input bool sendEmail = true;\n"
"input bool sendTerminalNotification = true;\n"
"\n"
"MqlTradeRequest tradeReq = {};\n"
"MqlTradeResult tradeRes = {};\n"
"uint fileContentDirections[];\n"
"long bypassMaxOrders = 0;\n"
"ulong orderResult, exceededOrdersTickets[];\n"
"int count, queueCounter = 0, exceededLotsOrders = 0, lotBypassCommand, lotBypassQueueCounter = 0, bypassModifyQueueCounter = 0, bypassCloseQueueCounter = 0,\n"
"           modifyQueueCounter = 0, closeQueueCounter = 0, pendingOrderType;\n"
"bool pendingOrderExists = false, marketOrderExists = false, pendingExists, marketExists, marketClosed = false,\n"
"     overnightBlocked = false, exceededMaxLots = false, bypassExists = false, bypassModifyQueue = false, bypassCloseQueue = false,\n"
"     closeQueue = false, modifyQueue = false, noTrading = false;\n"
"double tickSize, tickValue, lotStep, maximumLot, minimumLot, pointValue, tickValueFix, tsMABuy, tsMASell, lastExceededLots,\n"
"       stoploss, takeprofit, openprice, oLots, body, lowerWick, upperWick, lotBypassOpenprice, lotBypassStoploss, lotBypassTakeprofit,\n"
"       queueModifyStoploss = 0.0, commision = 0.0;\n"
"datetime barTime = 0, oExpiration, fileContent[], queueLastTime = 0, marketCloseEnabledTime = 0, overnightEnabledTime = 0,\n"
"         lotBypassLastTime = 0, lotBypassExpiration = 0, bypassModifyLastTime = 0, bypassCloseLastTime = 0, modifyLastTime = 0, closeLastTime = 0;\n"
"string queueCommand;\n";

string secondPartCode = 
"//+------------------------------------------------------------------+\n"
"//|Check if there is a match with generated signal                   |\n"
"//+------------------------------------------------------------------+\n"
"string checkForSignal()\n"
"  {\n"
"\n"
"   for(int x=0; x<ArraySize(fileContent); x++)\n"
"     {\n"
"      if(iTime(NULL, 0, 1) == fileContent[x])\n"
"        {\n"
"         if(fileContentDirections[x] == 0)\n"
"           {\n"
"            return \"SELL\";\n"
"           }\n"
"         if(fileContentDirections[x] == 1)\n"
"           {\n"
"            return \"BUY\";\n"
"           }\n"
"        }\n"
"     }\n"
"   return \"\";\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Prepare an order parameters based on the order type               |\n"
"//+------------------------------------------------------------------+\n"
"void prepareOrderParameters(string oType)\n"
"  {\n"
"\n"
"   if(!marketOrdersOnly)\n"
"     {\n"
"      if(oType == \"BUY\")\n"
"        {\n"
"         oType = \"PBUY\";\n"
"        }\n"
"      if(oType == \"SELL\")\n"
"        {\n"
"         oType = \"PSELL\";\n"
"        }\n"
"     }\n"
"\n"
"   if(pendingExpirationShift*(PeriodSeconds()/60) > 10)\n"
"     {\n"
"      oExpiration = iTime(NULL, 0, 0) + (pendingExpirationShift*PeriodSeconds());\n"
"     }\n"
"   else\n"
"     {\n"
"      oExpiration = 0;\n"
"     }\n"
"\n"
"   if((oType == \"BUY\" || oType == \"SELL\") && !marketOrderExists)\n"
"     {\n"
"      prepareEntry(oType);\n"
"      prepareStoploss(oType);\n"
"      prepareTakeprofit(oType);\n"
"      calculateLots(oType);\n"
"      placeOrder(oType);\n"
"      return;\n"
"     }\n"
"\n"
"   if((oType == \"PBUY\" || oType == \"PSELL\") && !marketOrderExists && !pendingOrderExists)\n"
"     {\n"
"      prepareEntry(oType);\n"
"      prepareStoploss(oType);\n"
"      prepareTakeprofit(oType);\n"
"      calculateLots(oType);\n"
"      placeOrder(oType);\n"
"      return;\n"
"     }\n"
"\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check for trailing stop type                                      |\n"
"//+------------------------------------------------------------------+\n"
"void checkTrailingStop()\n"
"  {\n"
"   if(trailingStop == 1)\n"
"     {\n"
"      checkTSHL();\n"
"     }\n"
"   if(trailingStop == 2)\n"
"     {\n"
"      checkTSMA();\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check the High/Low Trailing stop                                  |\n"
"//+------------------------------------------------------------------+\n"
"void checkTSHL()\n"
"  {\n"
"   if(!trailingStopCandleShift)\n"
"     {\n"
"      return;\n"
"     }\n"
"   if(PositionSelectByTicket(marketOrderTicket))\n"
"     {\n"
"      if(iTime(NULL, 0, 0) >= PositionGetInteger(POSITION_TIME) + PeriodSeconds() * trailingStopCandleShift)\n"
"        {\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && iHigh(NULL, 0, trailingStopCandleShift) > SymbolInfoDouble(NULL, SYMBOL_BID))\n"
"           {\n"
"            if(PositionGetDouble(POSITION_SL) > iHigh(NULL, 0, trailingStopCandleShift) && iHigh(NULL, 0, trailingStopCandleShift) > PositionGetDouble(POSITION_TP))\n"
"              {\n"
"               if(trailingStopOnlyInProfit)\n"
"                 {\n"
"                  if(OrderProfit(PositionGetInteger(POSITION_TICKET)) > 0)\n"
"                    {\n"
"                     if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), iHigh(NULL, 0, trailingStopCandleShift), PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                       {\n"
"                        if(!modifyQueue)\n"
"                           modifyQueue = !modifyQueue;\n"
"                        queueModifyStoploss = iHigh(NULL, 0, trailingStopCandleShift);\n"
"                        sendAlertEmailNotification(\"The trailing stop is unable to move the rstoploss to: \" + (string)iHigh(NULL, 0, trailingStopCandleShift) + \" the order, is now in queue\");\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        modifyLotBypassOrders(iHigh(NULL, 0, trailingStopCandleShift));\n"
"                       }\n"
"                    }\n"
"                 }\n"
"               else\n"
"                 {\n"
"                  if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), iHigh(NULL, 0, trailingStopCandleShift), PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                    {\n"
"                     if(!modifyQueue)\n"
"                        modifyQueue = !modifyQueue;\n"
"                     queueModifyStoploss = iHigh(NULL, 0, trailingStopCandleShift);\n"
"                     sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)iHigh(NULL, 0, trailingStopCandleShift) + \" the order, is now in queue\");\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     modifyLotBypassOrders(iHigh(NULL, 0, trailingStopCandleShift));\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && iLow(NULL, 0, trailingStopCandleShift) < SymbolInfoDouble(NULL, SYMBOL_ASK))\n"
"           {\n"
"            if(PositionGetDouble(POSITION_SL) < iLow(NULL, 0, trailingStopCandleShift) && iLow(NULL, 0, trailingStopCandleShift) < PositionGetDouble(POSITION_TP))\n"
"              {\n"
"               if(trailingStopOnlyInProfit)\n"
"                 {\n"
"                  if(OrderProfit(PositionGetInteger(POSITION_TICKET)) > 0)\n"
"                    {\n"
"                     if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), iLow(NULL, 0, trailingStopCandleShift), PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                       {\n"
"                        if(!modifyQueue)\n"
"                           modifyQueue = !modifyQueue;\n"
"                        queueModifyStoploss = iLow(NULL, 0, trailingStopCandleShift);\n"
"                        sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)iLow(NULL, 0, trailingStopCandleShift) + \" the order, is now in queue\");\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        modifyLotBypassOrders(iLow(NULL, 0, trailingStopCandleShift));\n"
"                       }\n"
"                    }\n"
"                 }\n"
"               else\n"
"                 {\n"
"                  if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), iLow(NULL, 0, trailingStopCandleShift), PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                    {\n"
"                     if(!modifyQueue)\n"
"                        modifyQueue = !modifyQueue;\n"
"                     queueModifyStoploss = iLow(NULL, 0, trailingStopCandleShift);\n"
"                     sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)iLow(NULL, 0, trailingStopCandleShift) + \" the order, is now in queue\");\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     modifyLotBypassOrders(iLow(NULL, 0, trailingStopCandleShift));\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check the moving average trailing stop                            |\n"
"//+------------------------------------------------------------------+\n"
"void checkTSMA()\n"
"  {\n"
"   if(!tsMACandleShift || !tsMAPeriod || !tsMACandleShiftAfterOpen)\n"
"     {\n"
"      return;\n"
"     }\n"
"\n"
"   if(PositionSelectByTicket(marketOrderTicket))\n"
"     {\n"
"      if(iTime(NULL, 0, 0) >= PositionGetInteger(POSITION_TIME) + PeriodSeconds() * tsMACandleShiftAfterOpen)\n"
"        {\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && tsMASell > SymbolInfoDouble(NULL, SYMBOL_BID))\n"
"           {\n"
"            if(PositionGetDouble(POSITION_SL) > tsMASell && tsMASell > PositionGetDouble(POSITION_TP))\n"
"              {\n"
"               if(trailingStopOnlyInProfit)\n"
"                 {\n"
"                  if(OrderProfit(PositionGetInteger(POSITION_TICKET)) > 0)\n"
"                    {\n"
"                     if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), tsMASell, PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                       {\n"
"                        if(!modifyQueue)\n"
"                           modifyQueue = !modifyQueue;\n"
"                        queueModifyStoploss = tsMASell;\n"
"                        sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)tsMASell + \" the order, is now in queue\");\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        modifyLotBypassOrders(tsMASell);\n"
"                       }\n"
"                    }\n"
"                 }\n"
"               else\n"
"                 {\n"
"                  if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), tsMASell, PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                    {\n"
"                     if(!modifyQueue)\n"
"                        modifyQueue = !modifyQueue;\n"
"                     queueModifyStoploss = tsMASell;\n"
"                     sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)tsMASell + \" the order, is now in queue\");\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     modifyLotBypassOrders(tsMASell);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && tsMABuy < SymbolInfoDouble(NULL, SYMBOL_ASK))\n"
"           {\n"
"            if(PositionGetDouble(POSITION_SL) < tsMABuy && tsMABuy < PositionGetDouble(POSITION_TP))\n"
"              {\n"
"               if(trailingStopOnlyInProfit)\n"
"                 {\n"
"                  if(OrderProfit(PositionGetInteger(POSITION_TICKET)) > 0)\n"
"                    {\n"
"                     if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), tsMABuy, PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                       {\n"
"                        if(!modifyQueue)\n"
"                           modifyQueue = !modifyQueue;\n"
"                        queueModifyStoploss = tsMABuy;\n"
"                        sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)tsMABuy + \" the order, is now in queue\");\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        modifyLotBypassOrders(tsMABuy);\n"
"                       }\n"
"                    }\n"
"                 }\n"
"               else\n"
"                 {\n"
"                  if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), tsMABuy, PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                    {\n"
"                     if(!modifyQueue)\n"
"                        modifyQueue = !modifyQueue;\n"
"                     queueModifyStoploss = tsMABuy;\n"
"                     sendAlertEmailNotification(\"The trailing stop is unable to move the stoploss to: \" + (string)tsMABuy + \" the order, is now in queue\");\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     modifyLotBypassOrders(tsMABuy);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Separate generated signals                                        |\n"
"//+------------------------------------------------------------------+\n"
"void prepareSignals()\n"
"  {\n"
"   string separatedSignals[];\n"
"   string separatedDirections[];\n"
"   if(StringSplit(signals, StringGetCharacter(\"/\", 0), separatedSignals))\n"
"     {\n"
"      ArrayResize(separatedSignals, ArraySize(separatedSignals)-1);\n"
"      for(int i=0; i<ArraySize(separatedSignals); i++)\n"
"        {\n"
"         arrayPush((datetime)separatedSignals[i], fileContent);\n"
"        }\n"
"     }\n"
"   else\n"
"     {\n"
"      sendAlertEmailNotification(\"Unable to load signals\");\n"
"     }\n"
"   if(StringSplit(directions, StringGetCharacter(\"/\", 0), separatedDirections))\n"
"     {\n"
"      ArrayResize(separatedDirections, ArraySize(separatedDirections)-1);\n"
"      for(int i=0; i<ArraySize(separatedDirections); i++)\n"
"        {\n"
"         arrayPushUInt((uint)separatedDirections[i], fileContentDirections);\n"
"        }\n"
"     }\n"
"   else\n"
"     {\n"
"      sendAlertEmailNotification(\"Unable to load directions\");\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Push value to an array                                            |\n"
"//+------------------------------------------------------------------+\n"
"void arrayPush(datetime inputValue, datetime &array[])\n"
"  {\n"
"   int c = ArrayResize(array, ArraySize(array)+1);\n"
"   array[ArraySize(array)-1] = inputValue;\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Try an order/position in the queue                                |\n"
"//+------------------------------------------------------------------+\n"
"void checkQueue()\n"
"  {\n"
"   if(queueCounter && queueCounter <= orderInQueueAttempts && queueLastTime + orderInQueueSecondsDelay <= TimeCurrent())\n"
"     {\n"
"      Print(\"Order in queue attempt \" + (string)queueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"      placeOrder(queueCommand);\n"
"\n"
"      queueLastTime = TimeCurrent();\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   if(queueCounter >= orderInQueueAttempts)\n"
"     {\n"
"      sendAlertEmailNotification(\"Unable to open the order in \" + (string)orderInQueueAttempts + \" attempts\");\n"
"      queueCounter = 0;\n"
"     }\n"
"\n"
"   if(modifyQueue)\n"
"     {\n"
"      queueModifyOrder();\n"
"     }\n"
"   if(closeQueue)\n"
"     {\n"
"      queueCloseOrder();\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Try to modify an order/position in the queue                      |\n"
"//+------------------------------------------------------------------+\n"
"void queueModifyOrder()\n"
"  {\n"
"   if(modifyQueueCounter < orderInQueueAttempts && modifyLastTime + orderInQueueSecondsDelay <= TimeCurrent())\n"
"     {\n"
"      ulong queueTicket = 0;\n"
"      int modifyErrorCounter = 0;\n"
"      for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"           {\n"
"            if(PositionGetInteger(POSITION_MAGIC) == EAMagicNumber && PositionGetString(POSITION_SYMBOL) == Symbol() && queueModifyStoploss && PositionGetDouble(POSITION_SL) != queueModifyStoploss)\n"
"              {\n"
"               if((PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && PositionGetDouble(POSITION_SL) >= queueModifyStoploss) || (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && PositionGetDouble(POSITION_SL) <= queueModifyStoploss))\n"
"                 {\n"
"                  sendAlertEmailNotification(\"The position \" + (string)PositionGetInteger(POSITION_TICKET) + \" the stoploss is already modified or below modified value\");\n"
"                  modifyQueueCounter = 0;\n"
"                  modifyLastTime = 0;\n"
"                  modifyQueue = false;\n"
"                  modifyLotBypassOrders(queueModifyStoploss);\n"
"                  queueTicket = PositionGetInteger(POSITION_TICKET);\n"
"                  return;\n"
"                 }\n"
"               if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), queueModifyStoploss ? queueModifyStoploss : PositionGetDouble(POSITION_SL), PositionGetDouble(POSITION_TP), 0, clrWhite))\n"
"                 {\n"
"                  modifyErrorCounter++;\n"
"                  queueTicket = PositionGetInteger(POSITION_TICKET);\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(OrderSelect(OrderGetTicket(i)))\n"
"           {\n"
"            if(OrderGetInteger(ORDER_MAGIC) == EAMagicNumber && OrderGetString(ORDER_SYMBOL) == Symbol() && queueModifyStoploss && OrderGetDouble(ORDER_SL) != queueModifyStoploss)\n"
"              {\n"
"               if((OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_BUY && OrderGetDouble(ORDER_SL) >= queueModifyStoploss) || (OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_SELL && OrderGetDouble(ORDER_SL) <= queueModifyStoploss))\n"
"                 {\n"
"                  sendAlertEmailNotification(\"The order \" + (string)OrderGetInteger(ORDER_TICKET) + \" the stoploss is already modified or below modified value\");\n"
"                  modifyQueueCounter = 0;\n"
"                  modifyLastTime = 0;\n"
"                  modifyQueue = false;\n"
"                  modifyLotBypassOrders(queueModifyStoploss);\n"
"                  queueTicket = OrderGetInteger(ORDER_TICKET);\n"
"                  return;\n"
"                 }\n"
"               if(!OrderModifyPosition(OrderGetInteger(ORDER_TICKET), OrderGetDouble(ORDER_PRICE_OPEN), queueModifyStoploss ? queueModifyStoploss : OrderGetDouble(ORDER_SL), OrderGetDouble(ORDER_TP), 0, clrWhite))\n"
"                 {\n"
"                  modifyErrorCounter++;\n"
"                  queueTicket = OrderGetInteger(ORDER_TICKET);\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"\n"
"      if(modifyErrorCounter)\n"
"        {\n"
"         modifyQueueCounter++;\n"
"         modifyLastTime = TimeCurrent();\n"
"         if(modifyQueueCounter == orderInQueueAttempts)\n"
"           {\n"
"            sendAlertEmailNotification(\"Unable to modify the order \" + (string)queueTicket + \" in queue, attempt \" + (string)modifyQueueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"            modifyQueueCounter = 0;\n"
"            modifyLastTime = 0;\n"
"            modifyQueue = false;\n"
"           }\n"
"         else\n"
"           {\n"
"            sendAlertEmailNotification(\"Unable to modify order \" + (string)queueTicket + \" in queue, attempt \" + (string)modifyQueueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"           }\n"
"        }\n"
"      else\n"
"        {\n"
"         modifyQueueCounter = 0;\n"
"         modifyLastTime = 0;\n"
"         modifyQueue = false;\n"
"         modifyLotBypassOrders(queueModifyStoploss);\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Try to close an order/position in the queue                       |\n"
"//+------------------------------------------------------------------+\n"
"void queueCloseOrder()\n"
"  {\n"
"   if(closeQueueCounter < orderInQueueAttempts && closeLastTime + orderInQueueSecondsDelay <= TimeCurrent())\n"
"     {\n"
"      ulong queueTicket = 0;\n"
"      int closeErrorCounter = 0;\n"
"      for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"           {\n"
"            if(PositionGetInteger(POSITION_MAGIC) == EAMagicNumber && PositionGetString(POSITION_SYMBOL) == Symbol())\n"
"              {\n"
"               if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY || PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"                 {\n"
"                  if(!OrderClose(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_VOLUME), PositionGetDouble(POSITION_PRICE_CURRENT), Slippage, clrWhite))\n"
"                    {\n"
"                     closeErrorCounter++;\n"
"                     queueTicket = PositionGetInteger(POSITION_TICKET);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(OrderSelect(OrderGetTicket(i)))\n"
"           {\n"
"            if(OrderGetInteger(ORDER_MAGIC) == EAMagicNumber && OrderGetString(ORDER_SYMBOL) == Symbol())\n"
"              {\n"
"               if(OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_BUY || OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_SELL)\n"
"                 {\n"
"                  if(!OrderDelete(OrderGetInteger(ORDER_TICKET), clrWhite))\n"
"                    {\n"
"                     closeErrorCounter++;\n"
"                     queueTicket = OrderGetInteger(ORDER_TICKET);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      if(closeErrorCounter)\n"
"        {\n"
"         closeQueueCounter++;\n"
"         closeLastTime = TimeCurrent();\n"
"         sendAlertEmailNotification(\"Unable to close/delete order \" + (string)queueTicket + \" in queue, attempt \" + (string)closeQueueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"        }\n"
"      else\n"
"        {\n"
"         closeQueueCounter = 0;\n"
"         closeLastTime = 0;\n"
"         closeQueue = false;\n"
"         closeLotBypassOrders();\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check if today is the specified trading day                       |\n"
"//+------------------------------------------------------------------+\n"
"bool isTradeDay()\n"
"  {\n"
"   if(TimeDayOfWeekMQL4(iTime(NULL, 0, 0)) >= tradeDaysFrom && TimeDayOfWeekMQL4(iTime(NULL, 0, 0)) <= tradeDaysTo && tradeDaysFrom <= 6 && tradeDaysTo <= 6)\n"
"     {\n"
"      return true;\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n";
string thirdPartCode = "ulong pendingOrderTicket, marketOrderTicket;\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check the margin before opening an order to prevent insufficient  |\n"
"//|funds error                                                       |\n"
"//+------------------------------------------------------------------+\n"
"bool checkMargin(int orderType, double vol, double entry)\n"
"  {\n"
"   double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);\n"
"   double margin = 1;\n"
"   bool ret = false;\n"
"\n"
"   ret = OrderCalcMargin((ENUM_ORDER_TYPE)orderType, Symbol(), vol, entry, margin);\n"
"\n"
"   if(freeMargin - margin <= 0.0 || !ret)\n"
"     {\n"
"      return false;\n"
"     }\n"
"   return true;\n"
"  }\n"
"//+------------------------------------------------------------------+\n"
"//|Get an actual close price for further calculations                |\n"
"//+------------------------------------------------------------------+\n"
"double OrderClosePrice(ulong ticket)\n"
"  {\n"
"   if(PositionSelectByTicket(ticket))\n"
"     {\n"
"      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)\n"
"        {\n"
"         return SymbolInfoDouble(Symbol(), SYMBOL_BID);\n"
"        }\n"
"      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"        {\n"
"         return SymbolInfoDouble(Symbol(), SYMBOL_ASK);\n"
"        }\n"
"     }\n"
"   return 0.0;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Get an actual profit of an order for further calculations         |\n"
"//+------------------------------------------------------------------+\n"
"double OrderProfit(ulong ticket)\n"
"  {\n"
"   if(PositionSelectByTicket(ticket))\n"
"     {\n"
"      double open = PositionGetDouble(POSITION_PRICE_OPEN);\n"
"      double current = PositionGetDouble(POSITION_PRICE_CURRENT);\n"
"      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)\n"
"        {\n"
"         return current - open;\n"
"        }\n"
"      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"        {\n"
"         return open - current;\n"
"        }\n"
"     }\n"
"   return 0.0;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Modify a position (an activated order) parameters                 |\n"
"//+------------------------------------------------------------------+\n"
"bool OrderModifyPosition(ulong ticket, double price, double sl, double tp, datetime expiry, color arrow)\n"
"  {\n"
"   ZeroMemory(tradeReq);\n"
"   ZeroMemory(tradeRes);\n"
"   if(PositionSelectByTicket(ticket))\n"
"     {\n"
"      tradeReq.action = TRADE_ACTION_SLTP;\n"
"      tradeReq.symbol = Symbol();\n"
"      tradeReq.sl = sl;\n"
"      tradeReq.tp = tp;\n"
"      tradeReq.position = ticket;\n"
"      if(OrderSend(tradeReq, tradeRes))\n"
"        {\n"
"         return true;\n"
"        }\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Modify a pending order parameters                                 |\n"
"//+------------------------------------------------------------------+\n"
"bool OrderModifyPending(ulong ticket, double price, double sl, double tp, datetime expiry, color arrow)\n"
"  {\n"
"   ZeroMemory(tradeReq);\n"
"   ZeroMemory(tradeRes);\n"
"   if(OrderSelect(ticket))\n"
"     {\n"
"      tradeReq.action = TRADE_ACTION_MODIFY;\n"
"      tradeReq.order = ticket;\n"
"      tradeReq.price = price;\n"
"      tradeReq.sl = sl;\n"
"      tradeReq.tp = tp;\n"
"      if(expiry)\n"
"        {\n"
"         tradeReq.type_time = ORDER_TIME_SPECIFIED;\n"
"         tradeReq.expiration = expiry;\n"
"        }\n"
"      else\n"
"        {\n"
"         tradeReq.type_time = ORDER_TIME_SPECIFIED;\n"
"         tradeReq.expiration = 0;\n"
"        }\n"
"      if(OrderSend(tradeReq, tradeRes))\n"
"        {\n"
"         return true;\n"
"        }\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Close an order (an activated order)                               |\n"
"//+------------------------------------------------------------------+\n"
"bool OrderClose(ulong ticket, double lots, double price, int slip, color arrow)\n"
"  {\n"
"   ZeroMemory(tradeReq);\n"
"   ZeroMemory(tradeRes);\n"
"   tradeReq.action = TRADE_ACTION_DEAL;\n"
"   tradeReq.position = ticket;\n"
"   tradeReq.symbol = Symbol();\n"
"   tradeReq.volume = lots;\n"
"   tradeReq.deviation = slip;\n"
"   tradeReq.magic = EAMagicNumber;\n"
"   tradeReq.type_filling = SymbolInfoInteger(_Symbol,SYMBOL_FILLING_MODE) == 1 ? ORDER_FILLING_FOK : SymbolInfoInteger(_Symbol,SYMBOL_FILLING_MODE) == 2 ? ORDER_FILLING_IOC : ORDER_FILLING_RETURN;\n"
"   if(PositionSelectByTicket(ticket))\n"
"     {\n"
"      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)\n"
"        {\n"
"         tradeReq.price = SymbolInfoDouble(Symbol(), SYMBOL_BID);\n"
"         tradeReq.type = ORDER_TYPE_SELL;\n"
"        }\n"
"      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"        {\n"
"         tradeReq.price = SymbolInfoDouble(Symbol(), SYMBOL_ASK);\n"
"         tradeReq.type = ORDER_TYPE_BUY;\n"
"        }\n"
"      if(OrderSend(tradeReq, tradeRes))\n"
"        {\n"
"         return true;\n"
"        }\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Delete a pending order                                            |\n"
"//+------------------------------------------------------------------+\n"
"bool OrderDelete(ulong ticket, color arrow = clrNONE)\n"
"  {\n"
"   ZeroMemory(tradeReq);\n"
"   ZeroMemory(tradeRes);\n"
"   tradeReq.action = TRADE_ACTION_REMOVE;\n"
"   tradeReq.order = ticket;\n"
"   if(OrderSend(tradeReq, tradeRes))\n"
"     {\n"
"      return true;\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Open an order (an instant order or a pending order)               |\n"
"//+------------------------------------------------------------------+\n"
"ulong MQL4OrderSend(string symbol, int type, double volume, double price, int slip, double sl, double tp, string comment, int magic, datetime expiry, color arrow)\n"
"  {\n"
"   ZeroMemory(tradeReq);\n"
"   ZeroMemory(tradeRes);\n"
"   ulong orderTicket = 0, result;\n"
"   if(!StringLen(symbol))\n"
"      symbol = Symbol();\n"
"   if(type == 0 || type == 1)\n"
"     {\n"
"      tradeReq.action = TRADE_ACTION_DEAL;\n"
"     }\n"
"   else\n"
"     {\n"
"      tradeReq.action = TRADE_ACTION_PENDING;\n"
"     }\n"
"   tradeReq.magic = magic;\n"
"   tradeReq.symbol = Symbol();\n"
"   tradeReq.volume = volume;\n"
"   tradeReq.price = price;\n"
"   tradeReq.sl = stoploss;\n"
"   tradeReq.tp = takeprofit;\n"
"   tradeReq.deviation = slip;\n"
"   tradeReq.type_filling = SymbolInfoInteger(_Symbol,SYMBOL_FILLING_MODE) == 1 ? ORDER_FILLING_FOK : SymbolInfoInteger(_Symbol,SYMBOL_FILLING_MODE) == 2 ? ORDER_FILLING_IOC : ORDER_FILLING_RETURN;\n"
"   tradeReq.type = (ENUM_ORDER_TYPE)type;\n"
"   tradeReq.expiration = expiry;\n"
"\n"
"   result = OrderSend(tradeReq, tradeRes);\n"
"   if(tradeRes.deal)\n"
"      orderTicket = tradeRes.deal;\n"
"   if(tradeRes.order)\n"
"      orderTicket = tradeRes.order;\n"
"   return orderTicket;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Get the hour from a datetime input                                |\n"
"//+------------------------------------------------------------------+\n"
"int TimeHourMQL4(datetime date)\n"
"  {\n"
"   MqlDateTime tm;\n"
"   TimeToStruct(date,tm);\n"
"   return(tm.hour);\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Get the day of the week from a datetime input                     |\n"
"//+------------------------------------------------------------------+\n"
"int TimeDayOfWeekMQL4(datetime date)\n"
"  {\n"
"   MqlDateTime tm;\n"
"   TimeToStruct(date,tm);\n"
"   return(tm.day_of_week);\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Initialization function                                           |\n"
"//+------------------------------------------------------------------+\n"
"int OnInit()\n"
"  {\n"
"   if(brokerCommision > 0)\n"
"     {\n"
"      commision = brokerCommision * SymbolInfoDouble(NULL, SYMBOL_TRADE_TICK_SIZE);\n"
"     }\n"
"   else\n"
"     {\n"
"      commision = 0;\n"
"     }\n"
"   if(bypassMaximumOrders > AccountInfoInteger(ACCOUNT_LIMIT_ORDERS))\n"
"     {\n"
"      bypassMaxOrders = AccountInfoInteger(ACCOUNT_LIMIT_ORDERS);\n"
"      sendAlertEmailNotification((string)bypassMaximumOrders + \" exceeds broker maximum orders, limit is now set to maximum: \" + (string)AccountInfoInteger(ACCOUNT_LIMIT_ORDERS));\n"
"     }\n"
"   else\n"
"     {\n"
"      bypassMaxOrders = bypassMaximumOrders;\n"
"     }\n"
"   checkPermissions();\n"
"   updateIndicators();\n"
"   prepareSignals();\n"
"   return(INIT_SUCCEEDED);\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Deinitialization function                                         |\n"
"//+------------------------------------------------------------------+\n"
"void OnDeinit(const int reason)\n"
"  {\n"
"  }\n"
"\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Update moving averages                                            |\n"
"//+------------------------------------------------------------------+\n"
"void updateIndicators()\n"
"  {\n"
"   if(trailingStop > 0 && trailingStop < 3)\n"
"     {\n"
"      if(tsMAAppliedPrice == 2 || tsMAAppliedPrice == 3)\n"
"        {\n"
"         tsMABuy = iMAMQL4(NULL, 0, tsMAPeriod, tsMAShift, tsMAMethod, PRICE_LOW, tsMACandleShift);\n"
"         tsMASell = iMAMQL4(NULL, 0, tsMAPeriod, tsMAShift, tsMAMethod, PRICE_HIGH, tsMACandleShift);\n"
"        }\n"
"      else\n"
"        {\n"
"         tsMABuy = iMAMQL4(NULL, 0, tsMAPeriod, tsMAShift, tsMAMethod, tsMAAppliedPrice, tsMACandleShift);\n"
"         tsMASell = iMAMQL4(NULL, 0, tsMAPeriod, tsMAShift, tsMAMethod, tsMAAppliedPrice, tsMACandleShift);\n"
"        }\n"
"      tsMABuy = MathRound(tsMABuy/SymbolInfoDouble(NULL, SYMBOL_POINT))*SymbolInfoDouble(NULL, SYMBOL_POINT);\n"
"      tsMASell = MathRound(tsMASell/SymbolInfoDouble(NULL, SYMBOL_POINT))*SymbolInfoDouble(NULL, SYMBOL_POINT);\n"
"     }\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check if algo trading is allowed                                  |\n"
"//+------------------------------------------------------------------+\n"
"void checkPermissions()\n"
"  {\n"
"   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))\n"
"      Alert(\"The algo trading is not allowed\");\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check for a new candle bar                                        |\n"
"//+------------------------------------------------------------------+\n"
"bool newBar()\n"
"  {\n"
"   if(barTime < iTime(NULL, 0, 0))\n"
"     {\n"
"      barTime = iTime(NULL, 0, 0);\n"
"      return true;\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check if now is the time to trade in specified time range         |\n"
"//+------------------------------------------------------------------+\n"
"bool isTradeTime()\n"
"  {\n"
"   if((TimeHourMQL4(iTime(NULL, 0, 0)) >= startHour) && (TimeHourMQL4(iTime(NULL, 0, 0)) <= endHour))\n"
"     {\n"
"      return true;\n"
"     }\n"
"   return false;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Get market values for further calculations                        |\n"
"//+------------------------------------------------------------------+\n"
"void getMarketValues()\n"
"  {\n"
"   tickSize = SymbolInfoDouble(NULL, SYMBOL_TRADE_TICK_SIZE);\n"
"   tickValue = SymbolInfoDouble(NULL, SYMBOL_TRADE_TICK_VALUE);\n"
"   lotStep = SymbolInfoDouble(NULL, SYMBOL_VOLUME_STEP);\n"
"   maximumLot = SymbolInfoDouble(NULL, SYMBOL_VOLUME_MAX);\n"
"   minimumLot = SymbolInfoDouble(NULL, SYMBOL_VOLUME_MIN);\n"
"   pointValue = SymbolInfoDouble(NULL, SYMBOL_POINT);\n"
"   tickValueFix = tickValue * pointValue / tickSize;\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Send input string as an alert/e-mail/notification                 |\n"
"//+------------------------------------------------------------------+\n"
"void sendAlertEmailNotification(string message)\n"
"  {\n"
"   if(StringLen(message))\n"
"     {\n"
"      if(sendAlert)\n"
"        {\n"
"         Alert(Symbol(), (string)(PeriodSeconds()/60), \" \", message);\n"
"        }\n"
"      if(sendEmail)\n"
"        {\n"
"         SendMail((string)AccountInfoInteger(ACCOUNT_LOGIN) + \" \" + Symbol() + (string)(PeriodSeconds()/60) + \" \" + message, message);\n"
"        }\n"
"      if(sendTerminalNotification)\n"
"        {\n"
"         SendNotification((string)AccountInfoInteger(ACCOUNT_LOGIN) + \" \" + Symbol() + (string)(PeriodSeconds()/60) + \" \" + message);\n"
"        }\n"
"     }\n"
"   else\n"
"     {\n"
"      Print(\"Error - the message is empty\");\n"
"      return;\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check if there are existing positions or orders                   |\n"
"//+------------------------------------------------------------------+\n"
"void checkForOrders()\n"
"  {\n"
"   pendingExists = false;\n"
"   marketExists = false;\n"
"   for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"     {\n"
"      if(OrderSelect(OrderGetTicket(i)))\n"
"        {\n"
"         if(OrderGetString(ORDER_SYMBOL) == Symbol() && OrderGetInteger(ORDER_MAGIC) == EAMagicNumber)\n"
"           {\n"
"            if(OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_BUY_LIMIT || OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_BUY_STOP || OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_SELL_LIMIT || OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_SELL_STOP)\n"
"              {\n"
"               pendingExists = true;\n"
"               if(OrderGetInteger(ORDER_TIME_EXPIRATION) == 0)\n"
"                 {\n"
"                  if((iTime(NULL, 0, iBarShift(NULL, 0, OrderGetInteger(ORDER_TIME_SETUP), false)) + ((pendingExpirationShift-1)*PeriodSeconds())) < iTime(NULL, 0, 0))\n"
"                    {\n"
"                     if(!OrderDelete(OrderGetInteger(ORDER_TICKET)))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Unable to delete the pending order \" + (string)OrderGetInteger(ORDER_TICKET) + \" , is now in queue\");\n"
"                        if(!closeQueue)\n"
"                           closeQueue = true;\n"
"                        queueLastTime = TimeCurrent();\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        pendingExists = false;\n"
"                        if(pendingOrderExists)\n"
"                          {\n"
"                           pendingOrderExists = !pendingOrderExists;\n"
"                           pendingOrderTicket = NULL;\n"
"                           checkForLotBypassOrders();\n"
"                           closeLotBypassOrders();\n"
"                           if(!bypassExists)\n"
"                             {\n"
"                              if(exceededMaxLots)\n"
"                                {\n"
"                                 exceededMaxLots = !exceededMaxLots;\n"
"                                 if(exceededLotsOrders)\n"
"                                    exceededLotsOrders = 0;\n"
"                                }\n"
"                             }\n"
"                          }\n"
"                       }\n"
"                    }\n"
"                 }\n"
"               if(pendingExists)\n"
"                 {\n"
"                  pendingOrderExists = true;\n"
"                  pendingOrderTicket = OrderGetInteger(ORDER_TICKET);\n"
"                  if(queueCounter)\n"
"                    {\n"
"                     queueCounter = 0;\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"\n"
"   if(PositionSelect(Symbol()))\n"
"     {\n"
"      if(PositionGetInteger(POSITION_MAGIC) == EAMagicNumber)\n"
"        {\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY || PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"           {\n"
"            marketExists = true;\n"
"            marketOrderExists = true;\n"
"            marketOrderTicket = PositionGetInteger(POSITION_TICKET);\n"
"            if(queueCounter)\n"
"              {\n"
"               queueCounter = 0;\n"
"              }\n"
"            if(orderProtection > 0)\n"
"               checkOrderProtection();\n"
"            if(moveToBE > 0 && moveToBE < 0.9)\n"
"               checkMoveToBE();\n"
"           }\n"
"        }\n"
"     }\n"
"\n"
"\n"
"\n"
"\n"
"   if(!pendingExists)\n"
"     {\n"
"      if(pendingOrderExists)\n"
"        {\n"
"         pendingOrderExists = false;\n"
"         pendingOrderTicket = NULL;\n"
"         if(!marketOrderExists)\n"
"           {\n"
"            checkForLotBypassOrders();\n"
"            closeLotBypassOrders();\n"
"            if(!bypassExists)\n"
"              {\n"
"               if(exceededMaxLots)\n"
"                 {\n"
"                  exceededMaxLots = !exceededMaxLots;\n"
"                  if(exceededLotsOrders)\n"
"                     exceededLotsOrders = 0;\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"\n"
"   if(!marketExists)\n"
"     {\n"
"      marketOrderExists = false;\n"
"      marketOrderTicket = NULL;\n"
"      if(!pendingOrderExists)\n"
"        {\n"
"         checkForLotBypassOrders();\n"
"         closeLotBypassOrders();\n"
"         if(!bypassExists)\n"
"           {\n"
"            if(exceededMaxLots)\n"
"              {\n"
"               exceededMaxLots = !exceededMaxLots;\n"
"               if(exceededLotsOrders)\n"
"                  exceededLotsOrders = 0;\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check if an order does not have a potentional to be profitable    |\n"
"//+------------------------------------------------------------------+\n"
"void checkOrderProtection()\n"
"  {\n"
"   if(PositionSelectByTicket(marketOrderTicket))\n"
"     {\n"
"      if(iTime(NULL, 0, iBarShift(NULL, 0, PositionGetInteger(POSITION_TIME))) + PeriodSeconds() * orderProtection < TimeCurrent() &&\n"
"         iTime(NULL, 0, iBarShift(NULL, 0, PositionGetInteger(POSITION_TIME))) + PeriodSeconds() * orderProtection + PeriodSeconds() > TimeCurrent())\n"
"        {\n"
"         if(((double)OrderProfit(PositionGetInteger(POSITION_TICKET))) < 0)\n"
"           {\n"
"            if(OrderClose(marketOrderTicket, PositionGetDouble(POSITION_VOLUME), PositionGetDouble(POSITION_PRICE_CURRENT), Slippage, clrGold))\n"
"              {\n"
"               sendAlertEmailNotification(\"OrderProtection has closed the order\");\n"
"               marketOrderExists = false;\n"
"               marketOrderTicket = NULL;\n"
"              }\n"
"            else\n"
"              {\n"
"               sendAlertEmailNotification(\"OrderProtection cannot close the order \" + (string)PositionGetInteger(POSITION_TICKET) + \" with error: \" + (string)GetLastError() + \" order, is now in queue\");\n"
"               if(!closeQueue)\n"
"                  closeQueue = !closeQueue;\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Move the stoploss to the breakeven before the takeprofit is       |\n"
"//|triggered                                                         |\n"
"//+------------------------------------------------------------------+\n"
"void checkMoveToBE()\n"
"  {\n"
"   if(!modifyQueue)\n"
"     {\n"
"      if(PositionSelectByTicket(marketOrderTicket))\n"
"        {\n"
"         double newStoploss = 0.0;\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && PositionGetDouble(POSITION_SL) < PositionGetDouble(POSITION_PRICE_OPEN))\n"
"           {\n"
"            if(PositionGetDouble(POSITION_PRICE_CURRENT) >= PositionGetDouble(POSITION_TP) - (PositionGetDouble(POSITION_TP) - PositionGetDouble(POSITION_PRICE_OPEN)) * moveToBE)\n"
"              {\n"
"               if(PositionGetDouble(POSITION_PRICE_OPEN) + (PositionGetDouble(POSITION_PRICE_OPEN) - PositionGetDouble(POSITION_SL)) * BETollerancePercentage > PositionGetDouble(POSITION_SL))\n"
"                 {\n"
"                  newStoploss = PositionGetDouble(POSITION_PRICE_OPEN) + (PositionGetDouble(POSITION_PRICE_OPEN) - PositionGetDouble(POSITION_SL)) * BETollerancePercentage;\n"
"                  newStoploss = MathRound(newStoploss/tickSize)*tickSize;\n"
"                  if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), newStoploss, PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                    {\n"
"                     if(!modifyQueue)\n"
"                        modifyQueue = !modifyQueue;\n"
"                     queueModifyStoploss = newStoploss;\n"
"                     sendAlertEmailNotification(\"Unable to move the stoploss to the BE on the order with error: \" + (string)GetLastError() + \" the order, is now in queue\");\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     sendAlertEmailNotification(\"Stoploss has been moved to the BE\");\n"
"                     modifyLotBypassOrders(newStoploss);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && PositionGetDouble(POSITION_SL) > PositionGetDouble(POSITION_PRICE_OPEN))\n"
"           {\n"
"            if(PositionGetDouble(POSITION_PRICE_CURRENT) <= PositionGetDouble(POSITION_TP) + (PositionGetDouble(POSITION_PRICE_OPEN) - PositionGetDouble(POSITION_TP)) * moveToBE)\n"
"              {\n"
"               if(PositionGetDouble(POSITION_PRICE_OPEN) - (PositionGetDouble(POSITION_SL) - PositionGetDouble(POSITION_PRICE_OPEN)) * BETollerancePercentage < PositionGetDouble(POSITION_SL))\n"
"                 {\n"
"                  newStoploss = PositionGetDouble(POSITION_PRICE_OPEN) - (PositionGetDouble(POSITION_SL) - PositionGetDouble(POSITION_PRICE_OPEN)) * BETollerancePercentage;\n"
"                  newStoploss = MathRound(newStoploss/tickSize)*tickSize;\n"
"                  if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), newStoploss, PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"                    {\n"
"                     if(!modifyQueue)\n"
"                        modifyQueue = !modifyQueue;\n"
"                     queueModifyStoploss = newStoploss;\n"
"                     sendAlertEmailNotification(\"Unable to move the stoploss to the BE on the order with error: \" + (string)GetLastError() + \" the order, is now in queue\");\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     sendAlertEmailNotification(\"Stoploss has been moved to the BE\");\n"
"                     modifyLotBypassOrders(newStoploss);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Calculate lots for an order or a position                         |\n"
"//+------------------------------------------------------------------+\n"
"void calculateLots(string oType)\n"
"  {\n"
"\n"
"   if(oType == \"SELL\" || oType == \"PSELL\")\n"
"     {\n"
"\n"
"      if(entryWithSpread)\n"
"        {\n"
"         stoploss = stoploss + (SymbolInfoInteger(NULL, SYMBOL_SPREAD) * SymbolInfoDouble(NULL, SYMBOL_TRADE_TICK_SIZE));\n"
"        }\n"
"      oLots = (MathFloor(((AccountInfoDouble(ACCOUNT_BALANCE) * Risk) / (((MathAbs(openprice - stoploss - commision) / tickSize) * tickValueFix))) / lotStep) * lotStep);\n"
"\n"
"      if(oLots > maximumLot)\n"
"        {\n"
"         if(bypassMaxLots)\n"
"           {\n"
"            exceededMaxLots = true;\n"
"            exceededLotsOrders = (int)MathFloor(oLots / maximumLot);\n"
"            lastExceededLots = MathMod(oLots, maximumLot);\n"
"            lastExceededLots = MathRound(lastExceededLots/minimumLot)*minimumLot;\n"
"            if(!lastExceededLots)\n"
"               lastExceededLots = minimumLot;\n"
"            oLots = maximumLot;\n"
"           }\n"
"         else\n"
"           {\n"
"            oLots = maximumLot;\n"
"           }\n"
"        }\n"
"\n"
"      if(oLots < minimumLot)\n"
"         oLots = minimumLot;\n"
"     }\n"
"   if(oType == \"BUY\" || oType == \"PBUY\")\n"
"     {\n"
"\n"
"      if(entryWithSpread)\n"
"        {\n"
"         stoploss = stoploss - (SymbolInfoInteger(NULL, SYMBOL_SPREAD) * SymbolInfoDouble(NULL, SYMBOL_TRADE_TICK_SIZE));\n"
"        }\n"
"\n"
"      oLots = (MathFloor(((AccountInfoDouble(ACCOUNT_BALANCE) * Risk) / (((MathAbs(openprice - stoploss - commision) / tickSize) * tickValueFix))) / lotStep) * lotStep);\n"
"      if(oLots > maximumLot)\n"
"        {\n"
"         if(bypassMaxLots)\n"
"           {\n"
"            exceededMaxLots = true;\n"
"            exceededLotsOrders = (int)MathFloor(oLots / maximumLot);\n"
"            lastExceededLots = MathMod(oLots, maximumLot);\n"
"            lastExceededLots = MathRound(lastExceededLots/minimumLot)*minimumLot;\n"
"            oLots = maximumLot;\n"
"           }\n"
"         else\n"
"           {\n"
"            oLots = maximumLot;\n"
"           }\n"
"        }\n"
"      if(oLots < minimumLot)\n"
"         oLots = minimumLot;\n"
"     }\n"
"\n"
"   oLots = MathRound(oLots/minimumLot)*minimumLot;\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Calculate the stoploss for an order or a position                 |\n"
"//+------------------------------------------------------------------+\n"
"void prepareStoploss(string oType)\n"
"  {\n"
"   if(oType == \"BUY\" || oType == \"PBUY\")\n"
"     {\n"
"\n"
"      if(stoplossOn == entryOn || stoplossOn == 0 || entryOn == 0)\n"
"        {\n"
"         if(entryWithSpread)\n"
"           {\n"
"            stoploss = iLow(NULL, 0, 1) - SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"            stoploss = MathRound(stoploss/pointValue)*pointValue;\n"
"           }\n"
"         else\n"
"           {\n"
"            stoploss = iLow(NULL, 0, 1);\n"
"           }\n"
"        }\n"
"      else\n"
"         if(stoplossOn < entryOn)\n"
"           {\n"
"            if(entryWithSpread)\n"
"              {\n"
"               stoploss = iHigh(NULL, 0, 1) - (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*entryOn - SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"               stoploss = MathRound(stoploss/pointValue)*pointValue;\n"
"              }\n"
"            else\n"
"              {\n"
"               stoploss = iHigh(NULL, 0, 1) - (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*entryOn;\n"
"              }\n"
"           }\n"
"         else\n"
"           {\n"
"            if(entryWithSpread)\n"
"              {\n"
"               stoploss = iHigh(NULL, 0, 1) - (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*stoplossOn - SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"               stoploss = MathRound(stoploss/pointValue)*pointValue;\n"
"              }\n"
"            else\n"
"              {\n"
"               stoploss = iHigh(NULL, 0, 1) - (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*stoplossOn;\n"
"              }\n"
"           }\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   if(oType == \"SELL\" || oType == \"PSELL\")\n"
"     {\n"
"\n"
"      if(stoplossOn == entryOn || stoplossOn == 0 || entryOn == 0)\n"
"        {\n"
"         if(entryWithSpread)\n"
"           {\n"
"            stoploss = iHigh(NULL, 0, 1) + SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"            stoploss = MathRound(stoploss/pointValue)*pointValue;\n"
"           }\n"
"         else\n"
"           {\n"
"            stoploss = iHigh(NULL, 0, 1);\n"
"           }\n"
"        }\n"
"      else\n"
"         if(stoplossOn < entryOn)\n"
"           {\n"
"            if(entryWithSpread)\n"
"              {\n"
"               stoploss = iLow(NULL, 0, 1) + (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*entryOn + SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"               stoploss = MathRound(stoploss/pointValue)*pointValue;\n"
"              }\n"
"            else\n"
"              {\n"
"               stoploss = iLow(NULL, 0, 1) + (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*entryOn;\n"
"              }\n"
"           }\n"
"         else\n"
"           {\n"
"            if(entryWithSpread)\n"
"              {\n"
"               stoploss = iLow(NULL, 0, 1) + (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*stoplossOn + SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"               stoploss = MathRound(stoploss/pointValue)*pointValue;\n"
"              }\n"
"            else\n"
"              {\n"
"               stoploss = iLow(NULL, 0, 1) + (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*stoplossOn;\n"
"              }\n"
"           }\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Calculate the takeprofit for an order or a position               |\n"
"//+------------------------------------------------------------------+\n"
"void prepareTakeprofit(string oType)\n"
"  {\n"
"\n"
"   if(oType == \"BUY\" || oType == \"PBUY\")\n"
"     {\n"
"\n"
"      if(takeprofitRatio > 0)\n"
"        {\n"
"         if(entryWithSpread)\n"
"           {\n"
"            takeprofit = openprice + (openprice - stoploss) * takeprofitRatio + SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"            takeprofit = MathRound(takeprofit/pointValue)*pointValue;\n"
"           }\n"
"         else\n"
"           {\n"
"            takeprofit = openprice + (openprice - stoploss) * takeprofitRatio;\n"
"            takeprofit = MathRound(takeprofit/pointValue)*pointValue;\n"
"           }\n"
"        }\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   if(oType == \"SELL\" || oType == \"PSELL\")\n"
"     {\n"
"      if(takeprofitRatio > 0)\n"
"        {\n"
"         if(entryWithSpread)\n"
"           {\n"
"            takeprofit = openprice - (stoploss - openprice) * takeprofitRatio - SymbolInfoInteger(NULL, SYMBOL_SPREAD) * pointValue;\n"
"            takeprofit = MathRound(takeprofit/pointValue)*pointValue;\n"
"           }\n"
"         else\n"
"           {\n"
"            takeprofit = openprice - (stoploss - openprice) * takeprofitRatio;\n"
"            takeprofit = MathRound(takeprofit/pointValue)*pointValue;\n"
"           }\n"
"\n"
"         if(takeprofit < 0)\n"
"            takeprofit = 0;\n"
"        }\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Calculate the entry price for an order or a position              |\n"
"//+------------------------------------------------------------------+\n"
"void prepareEntry(string oType)\n"
"  {\n"
"\n"
"   if(oType == \"BUY\")\n"
"     {\n"
"      openprice = SymbolInfoDouble(NULL, SYMBOL_ASK);\n"
"      return;\n"
"     }\n"
"\n"
"   if(oType == \"SELL\")\n"
"     {\n"
"      openprice = SymbolInfoDouble(NULL, SYMBOL_BID);\n"
"      return;\n"
"     }\n"
"\n"
"\n"
"   if(oType == \"PBUY\")\n"
"     {\n"
"\n"
"      if(stoplossOn == entryOn || stoplossOn == 0 || entryOn == 0)\n"
"        {\n"
"         openprice = iHigh(NULL, 0, 1);\n"
"        }\n"
"      else\n"
"         if(stoplossOn < entryOn)\n"
"           {\n"
"            openprice = iLow(NULL, 0, 1) + (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*stoplossOn;\n"
"            openprice = MathRound(openprice/pointValue)*pointValue;\n"
"           }\n"
"         else\n"
"           {\n"
"            openprice = iLow(NULL, 0, 1) + (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*entryOn;\n"
"            openprice = MathRound(openprice/pointValue)*pointValue;\n"
"           }\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   if(oType == \"PSELL\")\n"
"     {\n"
"\n"
"      if(stoplossOn == entryOn || stoplossOn == 0 || entryOn == 0)\n"
"        {\n"
"         openprice = iLow(NULL, 0, 1);\n"
"        }\n"
"      else\n"
"         if(stoplossOn < entryOn)\n"
"           {\n"
"            openprice = iHigh(NULL, 0, 1) - (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*stoplossOn;\n"
"            openprice = MathRound(openprice/pointValue)*pointValue;\n"
"           }\n"
"         else\n"
"           {\n"
"            openprice = iHigh(NULL, 0, 1) - (iHigh(NULL, 0, 1)-iLow(NULL, 0, 1))*entryOn;\n"
"            openprice = MathRound(openprice/pointValue)*pointValue;\n"
"           }\n"
"\n"
"      return;\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Place an order or a position                                      |\n"
"//+------------------------------------------------------------------+\n"
"void placeOrder(string oType)\n"
"  {\n"
"   int exceededOrdersCounter;\n"
"   int tempexceededLotsOrders;\n"
"   if(oType == \"PBUY\")\n"
"     {\n"
"\n"
"      if(openprice < SymbolInfoDouble(NULL, SYMBOL_ASK))\n"
"        {\n"
"         pendingOrderType = 2;\n"
"        }\n"
"      else\n"
"        {\n"
"         pendingOrderType = 4;\n"
"        }\n"
"\n"
"      if(!pendingOrderExists)\n"
"        {\n"
"         if(!checkMargin(pendingOrderType, oLots, openprice))\n"
"           {\n"
"            sendAlertEmailNotification(\"Not enough money to open the order\");\n"
"            return;\n"
"           }\n"
"         orderResult = MQL4OrderSend(Symbol(), pendingOrderType, oLots, openprice, Slippage, stoploss, takeprofit, EAComment, EAMagicNumber, oExpiration, clrBlue);\n"
"         if(!orderResult)\n"
"           {\n"
"            if(!queueCounter)\n"
"              {\n"
"               sendAlertEmailNotification(\"The position is in queue\");\n"
"              }\n"
"            queueCounter++;\n"
"            queueCommand = oType;\n"
"            queueLastTime = TimeCurrent();\n"
"           }\n"
"         if(orderResult)\n"
"           {\n"
"            if(exceededLotsOrders)\n"
"              {\n"
"               orderResult = 0;\n"
"               exceededOrdersCounter = 1;\n"
"               tempexceededLotsOrders = exceededLotsOrders;\n"
"               while(exceededLotsOrders)\n"
"                 {\n"
"                  if(exceededLotsOrders == 1)\n"
"                    {\n"
"                     if(!checkMargin(pendingOrderType, lastExceededLots, openprice))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the last exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), pendingOrderType, lastExceededLots, openprice, Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     if(!checkMargin(pendingOrderType, oLots, openprice))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), pendingOrderType, oLots, openprice, Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"\n"
"                  if(orderResult)\n"
"                    {\n"
"                     pushIntToArray(orderResult, exceededOrdersTickets);\n"
"                     exceededLotsOrders--;\n"
"                     if(bypassMaxOrders > 0 && bypassMaxOrders <= tempexceededLotsOrders)\n"
"                       {\n"
"                        exceededOrdersCounter++;\n"
"                       }\n"
"                    }\n"
"                  if(!orderResult)\n"
"                    {\n"
"                     lotBypassOpenprice = openprice;\n"
"                     lotBypassStoploss = stoploss;\n"
"                     lotBypassTakeprofit = takeprofit;\n"
"                     lotBypassExpiration  = oExpiration;\n"
"                     lotBypassCommand = pendingOrderType;\n"
"                     break;\n"
"                    }\n"
"                  if(exceededOrdersCounter >= bypassMaxOrders)\n"
"                    {\n"
"                     exceededLotsOrders = 0;\n"
"                     break;\n"
"                    }\n"
"                 }\n"
"               if(ArraySize(exceededOrdersTickets))\n"
"                 {\n"
"                  if(!bypassExists)\n"
"                     bypassExists = !bypassExists;\n"
"                 }\n"
"               if(exceededLotsOrders)\n"
"                 {\n"
"                  lotBypassLastTime = TimeCurrent();\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      return;\n"
"     }\n"
"   if(oType == \"PSELL\")\n"
"     {\n"
"\n"
"      if(openprice < SymbolInfoDouble(NULL, SYMBOL_BID))\n"
"        {\n"
"         pendingOrderType = 5;\n"
"        }\n"
"      else\n"
"        {\n"
"         pendingOrderType = 3;\n"
"        }\n"
"\n"
"      if(!pendingOrderExists)\n"
"        {\n"
"         if(!checkMargin(pendingOrderType, oLots, openprice))\n"
"           {\n"
"            sendAlertEmailNotification(\"Not enough money to open the order\");\n"
"            return;\n"
"           }\n"
"         orderResult = MQL4OrderSend(Symbol(), pendingOrderType, oLots, openprice, Slippage, stoploss, takeprofit, EAComment, EAMagicNumber, oExpiration, clrBlue);\n"
"         if(!orderResult)\n"
"           {\n"
"            if(!queueCounter)\n"
"              {\n"
"               sendAlertEmailNotification(\"The position is in queue\");\n"
"              }\n"
"            queueCounter++;\n"
"            queueCommand = oType;\n"
"            queueLastTime = TimeCurrent();\n"
"           }\n"
"         if(orderResult)\n"
"           {\n"
"            if(exceededLotsOrders)\n"
"              {\n"
"               orderResult = 0;\n"
"               exceededOrdersCounter = 1;\n"
"               tempexceededLotsOrders = exceededLotsOrders;\n"
"               while(exceededLotsOrders)\n"
"                 {\n"
"                  if(exceededLotsOrders == 1)\n"
"                    {\n"
"                     if(!checkMargin(pendingOrderType, lastExceededLots, openprice))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the last exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), pendingOrderType, lastExceededLots, openprice, Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     if(!checkMargin(pendingOrderType, oLots, openprice))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), pendingOrderType, oLots, openprice, Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"\n"
"                  if(orderResult)\n"
"                    {\n"
"                     pushIntToArray(orderResult, exceededOrdersTickets);\n"
"                     exceededLotsOrders--;\n"
"                     if(bypassMaxOrders > 0 && bypassMaxOrders <= tempexceededLotsOrders)\n"
"                       {\n"
"                        exceededOrdersCounter++;\n"
"                       }\n"
"                    }\n"
"                  if(!orderResult)\n"
"                    {\n"
"                     lotBypassOpenprice = openprice;\n"
"                     lotBypassStoploss = stoploss;\n"
"                     lotBypassTakeprofit = takeprofit;\n"
"                     lotBypassExpiration = oExpiration;\n"
"                     lotBypassCommand = pendingOrderType;\n"
"                     break;\n"
"                    }\n"
"                  if(exceededOrdersCounter >= bypassMaxOrders)\n"
"                    {\n"
"                     exceededLotsOrders = 0;\n"
"                     break;\n"
"                    }\n"
"                 }\n"
"               if(ArraySize(exceededOrdersTickets))\n"
"                 {\n"
"                  if(!bypassExists)\n"
"                     bypassExists = !bypassExists;\n"
"                 }\n"
"               if(exceededLotsOrders)\n"
"                 {\n"
"                  lotBypassLastTime = TimeCurrent();\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      return;\n"
"     }\n"
"\n"
"   if(oType == \"BUY\")\n"
"     {\n"
"      if(!marketOrderExists)\n"
"        {\n"
"         if(!checkMargin(0, oLots, SymbolInfoDouble(NULL, SYMBOL_ASK)))\n"
"           {\n"
"            sendAlertEmailNotification(\"Not enough money to open the order\");\n"
"            return;\n"
"           }\n"
"         orderResult = MQL4OrderSend(Symbol(), ORDER_TYPE_BUY, oLots, SymbolInfoDouble(NULL, SYMBOL_ASK), Slippage, stoploss, takeprofit, EAComment, EAMagicNumber, 0, clrBlue);\n"
"         if(!orderResult)\n"
"           {\n"
"            if(!queueCounter)\n"
"              {\n"
"               sendAlertEmailNotification(\"The position is in queue\");\n"
"              }\n"
"            queueCounter++;\n"
"            queueCommand = oType;\n"
"            queueLastTime = TimeCurrent();\n"
"           }\n"
"         if(orderResult)\n"
"           {\n"
"            if(exceededLotsOrders)\n"
"              {\n"
"               orderResult = 0;\n"
"               exceededOrdersCounter = 1;\n"
"               tempexceededLotsOrders = exceededLotsOrders;\n"
"               while(exceededLotsOrders)\n"
"                 {\n"
"                  if(exceededLotsOrders == 1)\n"
"                    {\n"
"                     if(!checkMargin(0, lastExceededLots, SymbolInfoDouble(NULL, SYMBOL_ASK)))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the last exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), ORDER_TYPE_BUY, lastExceededLots, SymbolInfoDouble(NULL, SYMBOL_ASK), Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     if(!checkMargin(0, oLots, SymbolInfoDouble(NULL, SYMBOL_ASK)))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), ORDER_TYPE_BUY, oLots, SymbolInfoDouble(NULL, SYMBOL_ASK), Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"\n"
"                  if(orderResult)\n"
"                    {\n"
"                     pushIntToArray(orderResult, exceededOrdersTickets);\n"
"                     exceededLotsOrders--;\n"
"                     if(bypassMaxOrders > 0 && bypassMaxOrders <= tempexceededLotsOrders)\n"
"                       {\n"
"                        exceededOrdersCounter++;\n"
"                       }\n"
"                    }\n"
"\n"
"                  if(!orderResult)\n"
"                    {\n"
"                     lotBypassOpenprice = openprice;\n"
"                     lotBypassStoploss = stoploss;\n"
"                     lotBypassTakeprofit = takeprofit;\n"
"                     lotBypassExpiration = oExpiration;\n"
"                     lotBypassCommand = pendingOrderType;\n"
"                     break;\n"
"                    }\n"
"                  if(exceededOrdersCounter >= bypassMaxOrders)\n"
"                    {\n"
"                     exceededLotsOrders = 0;\n"
"                     break;\n"
"                    }\n"
"                 }\n"
"               if(ArraySize(exceededOrdersTickets))\n"
"                 {\n"
"                  if(!bypassExists)\n"
"                     bypassExists = !bypassExists;\n"
"                 }\n"
"               if(exceededLotsOrders)\n"
"                 {\n"
"                  lotBypassLastTime = TimeCurrent();\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      return;\n"
"     }\n"
"   if(oType == \"SELL\")\n"
"     {\n"
"      if(!marketOrderExists)\n"
"        {\n"
"         if(!checkMargin(0, oLots, SymbolInfoDouble(NULL, SYMBOL_BID)))\n"
"           {\n"
"            sendAlertEmailNotification(\"Not enough money to open the order\");\n"
"            return;\n"
"           }\n"
"         orderResult = MQL4OrderSend(Symbol(), ORDER_TYPE_SELL, oLots, SymbolInfoDouble(NULL, SYMBOL_BID), Slippage, stoploss, takeprofit, EAComment, EAMagicNumber, 0, clrRed);\n"
"         if(!orderResult)\n"
"           {\n"
"            if(!queueCounter)\n"
"              {\n"
"               sendAlertEmailNotification(\"The position in queue\");\n"
"              }\n"
"            queueCounter++;\n"
"            queueCommand = oType;\n"
"            queueLastTime = TimeCurrent();\n"
"           }\n"
"         if(orderResult)\n"
"           {\n"
"            if(exceededLotsOrders)\n"
"              {\n"
"               orderResult = 0;\n"
"               exceededOrdersCounter = 1;\n"
"               tempexceededLotsOrders = exceededLotsOrders;\n"
"               while(exceededLotsOrders)\n"
"                 {\n"
"                  if(exceededLotsOrders == 1)\n"
"                    {\n"
"                     if(!checkMargin(0, lastExceededLots, SymbolInfoDouble(NULL, SYMBOL_BID)))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the last exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), ORDER_TYPE_SELL, lastExceededLots, SymbolInfoDouble(NULL, SYMBOL_BID), Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     if(!checkMargin(0, oLots, SymbolInfoDouble(NULL, SYMBOL_BID)))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Not enough money to open the exceeded order\");\n"
"                        exceededLotsOrders = 0;\n"
"                        return;\n"
"                       }\n"
"                     orderResult = MQL4OrderSend(Symbol(), ORDER_TYPE_SELL, oLots, openprice, Slippage, stoploss, takeprofit, EAComment, bypassMaxLotsMagicNumber, oExpiration, clrBlue);\n"
"                    }\n"
"                  if(orderResult)\n"
"                    {\n"
"                     pushIntToArray(orderResult, exceededOrdersTickets);\n"
"                     exceededLotsOrders--;\n"
"                     if(bypassMaxOrders > 0 && bypassMaxOrders <= tempexceededLotsOrders)\n"
"                       {\n"
"                        exceededOrdersCounter++;\n"
"                       }\n"
"                    }\n"
"                  if(!orderResult)\n"
"                    {\n"
"                     lotBypassOpenprice = openprice;\n"
"                     lotBypassStoploss = stoploss;\n"
"                     lotBypassTakeprofit = takeprofit;\n"
"                     lotBypassExpiration = oExpiration;\n"
"                     lotBypassCommand = pendingOrderType;\n"
"                     break;\n"
"                    }\n"
"                  if(exceededOrdersCounter >= bypassMaxOrders)\n"
"                    {\n"
"                     exceededLotsOrders = 0;\n"
"                     break;\n"
"                    }\n"
"                 }\n"
"               if(ArraySize(exceededOrdersTickets))\n"
"                 {\n"
"                  if(!bypassExists)\n"
"                     bypassExists = !bypassExists;\n"
"                 }\n"
"               if(exceededLotsOrders)\n"
"                 {\n"
"                  lotBypassLastTime = TimeCurrent();\n"
"                 }\n"
"              }\n"
"           }\n"
"\n"
"        }\n"
"      return;\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n";
string fourthPartCode = 
"//+------------------------------------------------------------------+\n"
"//|Check for the market close and possibly close orders/positions    |\n"
"//|before the market close                                           |\n"
"//+------------------------------------------------------------------+\n"
"void checkMarketClose()\n"
"  {\n"
"   if(closeOrdersBeforeMarketClose)\n"
"     {\n"
"      datetime dailyTime = iTime(NULL, PERIOD_D1, 0);\n"
"      if(TimeDayOfWeekMQL4(TimeCurrent()) == 5)\n"
"        {\n"
"         if(!marketClosed)\n"
"           {\n"
"            if(dailyTime + marketCloseFridayHour * 3600 <= TimeCurrent())\n"
"              {\n"
"               marketClosed = true;\n"
"               marketCloseEnabledTime = dailyTime;\n"
"               if(marketExists)\n"
"                 {\n"
"                  if(PositionSelectByTicket(marketOrderTicket))\n"
"                    {\n"
"                     if((closeOnlyLossOrdersBeforeMarketClose && OrderProfit(PositionGetInteger(POSITION_TICKET)) <= 0) || (closeOnlyProfitOrdersBeforeMarketClose && OrderProfit(PositionGetInteger(POSITION_TICKET)) > 0) || (!closeOnlyProfitOrdersBeforeMarketClose && !closeOnlyLossOrdersBeforeMarketClose))\n"
"                       {\n"
"                        if(!OrderClose(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_VOLUME), OrderClosePrice(PositionGetInteger(POSITION_TICKET)), Slippage, clrLime))\n"
"                          {\n"
"                           sendAlertEmailNotification(\"Unable to close the market order \" + (string)PositionGetInteger(POSITION_TICKET) + \" before market close with error: \" + (string)GetLastError() + \" order, is now in queue\");\n"
"                           if(!closeQueue)\n"
"                              closeQueue = !closeQueue;\n"
"                          }\n"
"                        else\n"
"                          {\n"
"                           sendAlertEmailNotification(\"The market order has been closed before market close\");\n"
"                           marketExists = false;\n"
"                           marketOrderTicket = 0;\n"
"                           closeLotBypassOrders();\n"
"                          }\n"
"                       }\n"
"                    }\n"
"                 }\n"
"               if(pendingExists)\n"
"                 {\n"
"                  if(OrderSelect(pendingOrderTicket))\n"
"                    {\n"
"                     if(!OrderDelete(OrderGetInteger(ORDER_TICKET), clrLime))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Unable to close the market order \" + (string)OrderGetInteger(ORDER_TICKET) + \" before market close with error: \" + (string)GetLastError() + \" order, is now in queue\");\n"
"                        if(!closeQueue)\n"
"                           closeQueue = !closeQueue;\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        sendAlertEmailNotification(\"The pending order has been deleted before market close\");\n"
"                        pendingExists = false;\n"
"                        pendingOrderTicket = 0;\n"
"                        closeLotBypassOrders();\n"
"                       }\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"         return;\n"
"        }\n"
"\n"
"      if(marketClosed && marketCloseEnabledTime + 1440 * 3 * 60 + marketOpenHour * 3600 <= TimeCurrent())\n"
"        {\n"
"         marketClosed = false;\n"
"        }\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Prevent trading overnight                                         |\n"
"//+------------------------------------------------------------------+\n"
"void checkOvernightTrading()\n"
"  {\n"
"   if(preventOvernightTrading)\n"
"     {\n"
"      datetime dailyTime = iTime(NULL, PERIOD_D1, 0);\n"
"      if(!marketClosed && !overnightBlocked)\n"
"        {\n"
"         if(dailyTime + preventOvernightTradingHour * 3600 <= TimeCurrent() && !overnightBlocked)\n"
"           {\n"
"            overnightBlocked = true;\n"
"            overnightEnabledTime = dailyTime;\n"
"            if(marketExists)\n"
"              {\n"
"               if(PositionSelectByTicket(marketOrderTicket))\n"
"                 {\n"
"                  if((closeOnlyOvernightLossOrders && OrderProfit(PositionGetInteger(POSITION_TICKET)) <= 0) || (closeOnlyOvernightProfitOrders && OrderProfit(PositionGetInteger(POSITION_TICKET)) > 0) || (!closeOnlyOvernightProfitOrders && !closeOnlyOvernightLossOrders))\n"
"                    {\n"
"                     if(!OrderClose(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_VOLUME), OrderClosePrice(PositionGetInteger(POSITION_TICKET)), Slippage, clrLime))\n"
"                       {\n"
"                        sendAlertEmailNotification(\"Unable to close the market order \" + (string)PositionGetInteger(POSITION_TICKET) + \" to prevent overnight trading with error: \" + (string)GetLastError() + \" order, is now in queue\");\n"
"                        if(!closeQueue)\n"
"                           closeQueue = !closeQueue;\n"
"                       }\n"
"                     else\n"
"                       {\n"
"                        sendAlertEmailNotification(\"The market order has been closed to prevent overnight trading\");\n"
"                        marketExists = false;\n"
"                        marketOrderTicket = 0;\n"
"                        closeLotBypassOrders();\n"
"                       }\n"
"                    }\n"
"                 }\n"
"              }\n"
"            if(pendingExists)\n"
"              {\n"
"               if(OrderSelect(pendingOrderTicket))\n"
"                 {\n"
"                  if(!OrderDelete(OrderGetInteger(ORDER_TICKET), clrLime))\n"
"                    {\n"
"                     sendAlertEmailNotification(\"Unable to close the market order \" + (string)OrderGetInteger(ORDER_TICKET) + \" to prevent overnight trading with error: \" + (string)GetLastError() + \" order, is now in queue\");\n"
"                     if(!closeQueue)\n"
"                        closeQueue = !closeQueue;\n"
"                    }\n"
"                  else\n"
"                    {\n"
"                     sendAlertEmailNotification(\"The pending order has been deleted to prevent overnight trading\");\n"
"                     pendingExists = false;\n"
"                     pendingOrderTicket = 0;\n"
"                     closeLotBypassOrders();\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"         return;\n"
"        }\n"
"\n"
"      if(overnightBlocked && overnightEnabledTime + 1440 * 60 + enableAfterOvernightTradingHour * 3600 <= TimeCurrent())\n"
"        {\n"
"         overnightBlocked = false;\n"
"         return;\n"
"        }\n"
"     }\n"
"\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Push an unsigned long to an array                                 |\n"
"//+------------------------------------------------------------------+\n"
"void pushIntToArray(ulong inputValue, ulong &array[])\n"
"  {\n"
"   int c = ArrayResize(array, ArraySize(array)+1);\n"
"   array[ArraySize(array)-1] = inputValue;\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Push an unsigned int to an array                                  |\n"
"//+------------------------------------------------------------------+\n"
"void arrayPushUInt(uint inputValue, uint &array[])\n"
"  {\n"
"   int c = ArrayResize(array, ArraySize(array)+1);\n"
"   array[ArraySize(array)-1] = inputValue;\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Put bypass maximum lots orders/positions in the queue             |\n"
"//+------------------------------------------------------------------+\n"
"void checkLotBypassQueue()\n"
"  {\n"
"   if(bypassMaxLots)\n"
"     {\n"
"      if(exceededLotsOrders)\n"
"        {\n"
"         int bypassOrderCounter = 0;\n"
"         if(marketOrderExists)\n"
"           {\n"
"            for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"              {\n"
"               if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"                 {\n"
"                  if(PositionGetInteger(POSITION_MAGIC) == bypassMaxLotsMagicNumber && PositionGetString(POSITION_SYMBOL) == Symbol())\n"
"                    {\n"
"                     bypassOrderCounter++;\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"\n"
"         if(pendingOrderExists)\n"
"           {\n"
"            for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"              {\n"
"               if(OrderSelect(OrderGetTicket(i)))\n"
"                 {\n"
"                  if(OrderGetInteger(ORDER_MAGIC) == bypassMaxLotsMagicNumber && OrderGetString(ORDER_SYMBOL) == Symbol())\n"
"                    {\n"
"                     bypassOrderCounter++;\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"         if(bypassOrderCounter != exceededLotsOrders)\n"
"           {\n"
"            if(bypassExists)\n"
"               bypassExists = !bypassExists;\n"
"            openLotBypassOrders();\n"
"            return;\n"
"           }\n"
"         else\n"
"           {\n"
"            bypassExists = true;\n"
"            exceededLotsOrders = 0;\n"
"            lotBypassOpenprice = 0.0;\n"
"            lotBypassStoploss = 0.0;\n"
"            lotBypassTakeprofit = 0.0;\n"
"            lotBypassExpiration = 0;\n"
"            lotBypassCommand = NULL;\n"
"            lotBypassLastTime = 0;\n"
"            lastExceededLots = 0.0;\n"
"            lotBypassQueueCounter = 0;\n"
"            return;\n"
"           }\n"
"        }\n"
"      if(bypassModifyQueue)\n"
"        {\n"
"         queueModifyLotBypassOrders();\n"
"        }\n"
"      if(bypassCloseQueue)\n"
"        {\n"
"         queueCloseLotBypassOrders();\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Open bypass maximum lots orders/positions                         |\n"
"//+------------------------------------------------------------------+\n"
"void openLotBypassOrders()\n"
"  {\n"
"   if(lotBypassQueueCounter < orderInQueueAttempts && lotBypassLastTime + orderInQueueSecondsDelay <= TimeCurrent())\n"
"     {\n"
"      int bypassOrdersCounter = 0;\n"
"      if(lotBypassCommand == 0 || lotBypassCommand == 1)\n"
"        {\n"
"         for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"           {\n"
"            if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"              {\n"
"               if(PositionGetInteger(POSITION_MAGIC) == bypassMaxLotsMagicNumber)\n"
"                 {\n"
"                  bypassOrdersCounter++;\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      else\n"
"        {\n"
"         for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"           {\n"
"            if(OrderSelect(OrderGetTicket(i)))\n"
"              {\n"
"               if(OrderGetInteger(ORDER_MAGIC) == bypassMaxLotsMagicNumber)\n"
"                 {\n"
"                  bypassOrdersCounter++;\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"\n"
"      while(exceededLotsOrders)\n"
"        {\n"
"         if(exceededLotsOrders == 1)\n"
"           {\n"
"            orderResult = MQL4OrderSend(NULL, lotBypassCommand, lastExceededLots, lotBypassOpenprice, Slippage, lotBypassStoploss, lotBypassTakeprofit, NULL, bypassMaxLotsMagicNumber, lotBypassExpiration, clrMagenta);\n"
"            if(orderResult >= 0)\n"
"              {\n"
"               pushIntToArray(orderResult, exceededOrdersTickets);\n"
"               exceededLotsOrders--;\n"
"               if(bypassMaxOrders > 0 && bypassMaxOrders <= bypassOrdersCounter)\n"
"                 {\n"
"                  bypassOrdersCounter++;\n"
"                 }\n"
"              }\n"
"            else\n"
"              {\n"
"               break;\n"
"              }\n"
"           }\n"
"         else\n"
"           {\n"
"            orderResult = MQL4OrderSend(NULL, lotBypassCommand, maximumLot, lotBypassOpenprice, Slippage, lotBypassStoploss, lotBypassTakeprofit, NULL, bypassMaxLotsMagicNumber, lotBypassExpiration, clrMagenta);\n"
"            if(orderResult >= 0)\n"
"              {\n"
"               pushIntToArray(orderResult, exceededOrdersTickets);\n"
"               exceededLotsOrders--;\n"
"               if(bypassMaxOrders > 0 && bypassMaxOrders <= bypassOrdersCounter)\n"
"                 {\n"
"                  bypassOrdersCounter++;\n"
"                 }\n"
"              }\n"
"            else\n"
"              {\n"
"               break;\n"
"              }\n"
"           }\n"
"\n"
"         if(bypassOrdersCounter >= bypassMaxOrders)\n"
"           {\n"
"            break;\n"
"           }\n"
"\n"
"        }\n"
"      lotBypassQueueCounter++;\n"
"      lotBypassLastTime = TimeCurrent();\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Modify bypass maximum lots orders/positions in the queue          |\n"
"//+------------------------------------------------------------------+\n"
"void queueModifyLotBypassOrders()\n"
"  {\n"
"   if(bypassModifyQueueCounter < orderInQueueAttempts && bypassModifyLastTime + orderInQueueSecondsDelay <= TimeCurrent())\n"
"     {\n"
"      ulong queueTicket = 0;\n"
"      int modifyErrorCounter = 0;\n"
"      for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"           {\n"
"            if(PositionGetInteger(POSITION_MAGIC) == bypassMaxLotsMagicNumber && PositionGetString(POSITION_SYMBOL) == Symbol() && queueModifyStoploss && PositionGetDouble(POSITION_SL) != queueModifyStoploss)\n"
"              {\n"
"               if((PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && PositionGetDouble(POSITION_SL) >= queueModifyStoploss) || (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && PositionGetDouble(POSITION_SL) <= queueModifyStoploss))\n"
"                 {\n"
"                  sendAlertEmailNotification(\"The position \" + (string)PositionGetInteger(POSITION_TICKET) + \" the stoploss is already modified or below modified value\");\n"
"                  modifyQueueCounter = 0;\n"
"                  modifyLastTime = 0;\n"
"                  modifyQueue = false;\n"
"                  modifyLotBypassOrders(queueModifyStoploss);\n"
"                  queueTicket = PositionGetInteger(POSITION_TICKET);\n"
"                  return;\n"
"                 }\n"
"\n"
"               if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), queueModifyStoploss ? queueModifyStoploss : PositionGetDouble(POSITION_SL), PositionGetDouble(POSITION_TP), 0, clrWhite))\n"
"                 {\n"
"                  modifyErrorCounter++;\n"
"                  queueTicket = PositionGetInteger(POSITION_TICKET);\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(OrderSelect(OrderGetTicket(i)))\n"
"           {\n"
"            if(OrderGetInteger(ORDER_MAGIC) == bypassMaxLotsMagicNumber && OrderGetString(ORDER_SYMBOL) == Symbol() && queueModifyStoploss && OrderGetDouble(ORDER_SL) != queueModifyStoploss)\n"
"              {\n"
"               if((OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_BUY && OrderGetDouble(ORDER_SL) >= queueModifyStoploss) || (OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_SELL && OrderGetDouble(ORDER_SL) <= queueModifyStoploss))\n"
"                 {\n"
"                  sendAlertEmailNotification(\"The order \" + (string)OrderGetInteger(ORDER_TICKET) + \" the stoploss is already modified or below modified value\");\n"
"                  modifyQueueCounter = 0;\n"
"                  modifyLastTime = 0;\n"
"                  modifyQueue = false;\n"
"                  modifyLotBypassOrders(queueModifyStoploss);\n"
"                  queueTicket = OrderGetInteger(ORDER_TICKET);\n"
"                  return;\n"
"                 }\n"
"\n"
"               if(!OrderModifyPosition(OrderGetInteger(ORDER_TICKET), OrderGetDouble(ORDER_PRICE_OPEN), queueModifyStoploss ? queueModifyStoploss : OrderGetDouble(ORDER_SL), OrderGetDouble(ORDER_TP), 0, clrWhite))\n"
"                 {\n"
"                  modifyErrorCounter++;\n"
"                  queueTicket = OrderGetInteger(ORDER_TICKET);\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"\n"
"      if(modifyErrorCounter)\n"
"        {\n"
"         bypassModifyQueueCounter++;\n"
"         bypassModifyLastTime = TimeCurrent();\n"
"         if(bypassModifyQueueCounter == orderInQueueAttempts)\n"
"           {\n"
"            sendAlertEmailNotification(\"Unable to modify the order \" + (string)queueTicket + \" in queue, attempt \" + (string)bypassModifyQueueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"            bypassModifyQueueCounter = 0;\n"
"            bypassModifyLastTime = 0;\n"
"            bypassModifyQueue = false;\n"
"           }\n"
"         else\n"
"           {\n"
"            sendAlertEmailNotification(\"Unable to modify the order \" + (string)queueTicket + \" in queue, attempt \" + (string)bypassModifyQueueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"           }\n"
"        }\n"
"      else\n"
"        {\n"
"         bypassModifyQueueCounter = 0;\n"
"         bypassModifyLastTime = 0;\n"
"         bypassModifyQueue = false;\n"
"         queueModifyStoploss = 0.0;\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Close bypass maximum lots orders/positions in the queue           |\n"
"//+------------------------------------------------------------------+\n"
"void queueCloseLotBypassOrders()\n"
"  {\n"
"   if(bypassCloseQueueCounter < orderInQueueAttempts && bypassCloseLastTime + orderInQueueSecondsDelay <= TimeCurrent())\n"
"     {\n"
"      ulong queueTicket = 0;\n"
"      int closeErrorCounter = 0;\n"
"      for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(OrderSelect(OrderGetTicket(i)))\n"
"           {\n"
"            if(OrderGetInteger(ORDER_TICKET) == bypassMaxLotsMagicNumber)\n"
"              {\n"
"               if(OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_BUY_LIMIT || OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_BUY_STOP || OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_SELL_STOP || OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_SELL_LIMIT)\n"
"                 {\n"
"                  if(!OrderDelete(OrderGetInteger(ORDER_TICKET), clrWhite))\n"
"                    {\n"
"                     closeErrorCounter++;\n"
"                     queueTicket = OrderGetInteger(ORDER_TICKET);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"        {\n"
"         if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"           {\n"
"            if(PositionGetInteger(POSITION_MAGIC) == bypassMaxLotsMagicNumber)\n"
"              {\n"
"               if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY || PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"                 {\n"
"                  if(!OrderClose(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_VOLUME), OrderClosePrice(OrderGetInteger(ORDER_TICKET)), Slippage, clrWhite))\n"
"                    {\n"
"                     closeErrorCounter++;\n"
"                     queueTicket = PositionGetInteger(POSITION_TICKET);\n"
"                    }\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"\n"
"      if(closeErrorCounter)\n"
"        {\n"
"         bypassCloseQueueCounter++;\n"
"         bypassCloseLastTime = TimeCurrent();\n"
"         sendAlertEmailNotification(\"Unable to close/delete order \" + (string)queueTicket + \" in queue, attempt \" + (string)bypassModifyQueueCounter + \" of \" + (string)orderInQueueAttempts);\n"
"        }\n"
"      else\n"
"        {\n"
"         bypassCloseQueueCounter = 0;\n"
"         bypassCloseLastTime = 0;\n"
"         bypassCloseQueue = false;\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Modify bypass maximum lots orders/positions                       |\n"
"//+------------------------------------------------------------------+\n"
"void modifyLotBypassOrders(double sl = 0.0)\n"
"  {\n"
"   if(ArraySize(exceededOrdersTickets) && bypassExists)\n"
"     {\n"
"      int modifyErrorCounter = 0;\n"
"      for(int i=0; i<ArraySize(exceededOrdersTickets); i++)\n"
"        {\n"
"         if(OrderSelect(exceededOrdersTickets[i]))\n"
"           {\n"
"            if(!OrderModifyPending(OrderGetInteger(ORDER_TICKET), OrderGetDouble(ORDER_PRICE_OPEN), sl ? sl : OrderGetDouble(ORDER_SL), OrderGetDouble(ORDER_TP), OrderGetInteger(ORDER_TIME_EXPIRATION), clrGold))\n"
"              {\n"
"               sendAlertEmailNotification(\"Unable to modify the exceeded lots \" + (string)OrderGetInteger(ORDER_TICKET) + \" the order is in queue \");\n"
"               modifyErrorCounter++;\n"
"              }\n"
"           }\n"
"         if(PositionSelectByTicket(exceededOrdersTickets[i]))\n"
"           {\n"
"            if(!OrderModifyPosition(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_PRICE_OPEN), sl ? sl : PositionGetDouble(POSITION_SL), PositionGetDouble(POSITION_TP), 0, clrGold))\n"
"              {\n"
"               sendAlertEmailNotification(\"Unable to modify the exceeded lots \" + (string)PositionGetInteger(POSITION_TICKET) + \" the order is in queue \");\n"
"               modifyErrorCounter++;\n"
"              }\n"
"           }\n"
"        }\n"
"\n"
"      if(modifyErrorCounter)\n"
"        {\n"
"         if(!bypassModifyQueue)\n"
"            bypassModifyQueue = !bypassModifyQueue;\n"
"         queueModifyStoploss = sl;\n"
"        }\n"
"     }\n"
"   else\n"
"     {\n"
"      if(bypassExists)\n"
"         bypassExists = !bypassExists;\n"
"      ArrayFree(exceededOrdersTickets);\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Close bypass lots orders/positions                                |\n"
"//+------------------------------------------------------------------+\n"
"void closeLotBypassOrders()\n"
"  {\n"
"   if(bypassExists && ArraySize(exceededOrdersTickets))\n"
"     {\n"
"      int closeErrorCounter = 0;\n"
"      for(int i=0; i<ArraySize(exceededOrdersTickets); i++)\n"
"        {\n"
"         if(OrderSelect(exceededOrdersTickets[i]))\n"
"           {\n"
"            if(OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_BUY_LIMIT || OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_BUY_STOP || OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_SELL_LIMIT || OrderGetInteger(ORDER_TYPE) != ORDER_TYPE_SELL_STOP)\n"
"              {\n"
"               if(!OrderDelete(OrderGetInteger(ORDER_TICKET), clrWhite))\n"
"                 {\n"
"                  sendAlertEmailNotification(\"Unable to delete the exceeded lots \" + (string)OrderGetInteger(ORDER_TICKET) + \" the order, is now in queue \");\n"
"                  closeErrorCounter++;\n"
"                  if(!bypassCloseQueue)\n"
"                     bypassCloseQueue = !bypassCloseQueue;\n"
"                  return;\n"
"                 }\n"
"              }\n"
"           }\n"
"         if(PositionSelectByTicket(exceededOrdersTickets[i]))\n"
"           {\n"
"            if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY || PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)\n"
"              {\n"
"               if(!OrderClose(PositionGetInteger(POSITION_TICKET), PositionGetDouble(POSITION_VOLUME), OrderClosePrice(PositionGetInteger(POSITION_TICKET)), Slippage, clrWhite))\n"
"                 {\n"
"                  sendAlertEmailNotification(\"Unable to close the exceeded lots \" + (string)PositionGetInteger(POSITION_TICKET) + \" the order, is now in queue \");\n"
"                  closeErrorCounter++;\n"
"                  if(!bypassCloseQueue)\n"
"                     bypassCloseQueue = !bypassCloseQueue;\n"
"                  return;\n"
"                 }\n"
"              }\n"
"           }\n"
"        }\n"
"      if(!closeErrorCounter)\n"
"        {\n"
"         bypassExists = false;\n"
"         ArrayFree(exceededOrdersTickets);\n"
"         if(bypassCloseQueue)\n"
"            bypassCloseQueue = !bypassCloseQueue;\n"
"        }\n"
"      else\n"
"        {\n"
"         bypassCloseLastTime = TimeCurrent();\n"
"        }\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|Check if bypass maximum lots orders/positions exists              |\n"
"//+------------------------------------------------------------------+\n"
"void checkForLotBypassOrders()\n"
"  {\n"
"   ulong existingBypassOrders[], c;\n"
"   for(int i=OrdersTotal()-1; i >= 0; i--)\n"
"     {\n"
"      if(OrderSelect(OrderGetTicket(i)))\n"
"        {\n"
"         if(OrderGetInteger(ORDER_TICKET) == bypassMaxLotsMagicNumber && OrderGetString(ORDER_SYMBOL) == Symbol())\n"
"           {\n"
"            pushIntToArray(OrderGetInteger(ORDER_TICKET), existingBypassOrders);\n"
"           }\n"
"        }\n"
"     }\n"
"   for(int i=PositionsTotal()-1; i >= 0; i--)\n"
"     {\n"
"      if(PositionSelectByTicket(PositionGetTicket(i)))\n"
"        {\n"
"         if(PositionGetInteger(POSITION_MAGIC) == bypassMaxLotsMagicNumber && PositionGetString(POSITION_SYMBOL) == Symbol())\n"
"           {\n"
"            pushIntToArray(PositionGetInteger(POSITION_TICKET), existingBypassOrders);\n"
"           }\n"
"        }\n"
"     }\n"
"   if(ArraySize(existingBypassOrders))\n"
"     {\n"
"      if(ArraySize(exceededOrdersTickets))\n"
"        {\n"
"         ArrayFree(exceededOrdersTickets);\n"
"         c = ArrayCopy(exceededOrdersTickets, existingBypassOrders);\n"
"         if(!bypassExists)\n"
"            bypassExists = !bypassExists;\n"
"         return;\n"
"        }\n"
"      else\n"
"        {\n"
"         c = ArrayCopy(exceededOrdersTickets, existingBypassOrders);\n"
"         if(!bypassExists)\n"
"            bypassExists = !bypassExists;\n"
"         return;\n"
"        }\n"
"     }\n"
"   else\n"
"     {\n"
"      if(!bypassExists)\n"
"         bypassExists = !bypassExists;\n"
"      return;\n"
"     }\n"
"   return;\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|On every price tick                                               |\n"
"//+------------------------------------------------------------------+\n"
"void OnTick()\n"
"  {\n"
"   if(!noTrading)\n"
"     {\n"
"      checkForLotBypassOrders();\n"
"      checkForOrders();\n"
"      checkQueue();\n"
"      checkMarketClose();\n"
"      checkOvernightTrading();\n"
"      checkLotBypassQueue();\n"
"      if(isTradeTime() && isTradeDay())\n"
"        {\n"
"         getMarketValues();\n"
"         if(newBar())\n"
"           {\n"
"            updateIndicators();\n"
"            if(trailingStop && marketOrderExists)\n"
"              {\n"
"               checkTrailingStop();\n"
"              }\n"
"            prepareOrderParameters(checkForSignal());\n"
"            if(openPriceBacktest)\n"
"              {\n"
"               checkForOrders();\n"
"              }\n"
"           }\n"
"        }\n"
"     }\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|MQL4 Timeframe wrapper|\n"
"//+------------------------------------------------------------------+\n"
"ENUM_TIMEFRAMES TFMigrate(int tf)\n"
"  {\n"
"   switch(tf)\n"
"     {\n"
"      case 0:\n"
"         return(PERIOD_CURRENT);\n"
"      case 1:\n"
"         return(PERIOD_M1);\n"
"      case 5:\n"
"         return(PERIOD_M5);\n"
"      case 15:\n"
"         return(PERIOD_M15);\n"
"      case 30:\n"
"         return(PERIOD_M30);\n"
"      case 60:\n"
"         return(PERIOD_H1);\n"
"      case 240:\n"
"         return(PERIOD_H4);\n"
"      case 1440:\n"
"         return(PERIOD_D1);\n"
"      case 10080:\n"
"         return(PERIOD_W1);\n"
"      case 43200:\n"
"         return(PERIOD_MN1);\n"
"\n"
"      case 2:\n"
"         return(PERIOD_M2);\n"
"      case 3:\n"
"         return(PERIOD_M3);\n"
"      case 4:\n"
"         return(PERIOD_M4);\n"
"      case 6:\n"
"         return(PERIOD_M6);\n"
"      case 10:\n"
"         return(PERIOD_M10);\n"
"      case 12:\n"
"         return(PERIOD_M12);\n"
"      case 16385:\n"
"         return(PERIOD_H1);\n"
"      case 16386:\n"
"         return(PERIOD_H2);\n"
"      case 16387:\n"
"         return(PERIOD_H3);\n"
"      case 16388:\n"
"         return(PERIOD_H4);\n"
"      case 16390:\n"
"         return(PERIOD_H6);\n"
"      case 16392:\n"
"         return(PERIOD_H8);\n"
"      case 16396:\n"
"         return(PERIOD_H12);\n"
"      case 16408:\n"
"         return(PERIOD_D1);\n"
"      case 32769:\n"
"         return(PERIOD_W1);\n"
"      case 49153:\n"
"         return(PERIOD_MN1);\n"
"      default:\n"
"         return(PERIOD_CURRENT);\n"
"     }\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|MQL4 MA Method wrapper                                            |\n"
"//+------------------------------------------------------------------+\n"
"ENUM_MA_METHOD MethodMigrate(int method)\n"
"  {\n"
"   switch(method)\n"
"     {\n"
"      case 0:\n"
"         return(MODE_SMA);\n"
"      case 1:\n"
"         return(MODE_EMA);\n"
"      case 2:\n"
"         return(MODE_SMMA);\n"
"      case 3:\n"
"         return(MODE_LWMA);\n"
"      default:\n"
"         return(MODE_SMA);\n"
"     }\n"
"  }\n"
"//+------------------------------------------------------------------+\n"
"//|MQL4 Price wrapper                                                |\n"
"//+------------------------------------------------------------------+\n"
"ENUM_APPLIED_PRICE PriceMigrate(int price)\n"
"  {\n"
"   switch(price)\n"
"     {\n"
"      case 1:\n"
"         return(PRICE_CLOSE);\n"
"      case 2:\n"
"         return(PRICE_OPEN);\n"
"      case 3:\n"
"         return(PRICE_HIGH);\n"
"      case 4:\n"
"         return(PRICE_LOW);\n"
"      case 5:\n"
"         return(PRICE_MEDIAN);\n"
"      case 6:\n"
"         return(PRICE_TYPICAL);\n"
"      case 7:\n"
"         return(PRICE_WEIGHTED);\n"
"      default:\n"
"         return(PRICE_CLOSE);\n"
"     }\n"
"  }\n"
"//+------------------------------------------------------------------+\n"
"//|MQL4 Stochastic field wrapper                                     |\n"
"//+------------------------------------------------------------------+\n"
"ENUM_STO_PRICE StoFieldMigrate(int field)\n"
"  {\n"
"   switch(field)\n"
"     {\n"
"      case 0:\n"
"         return(STO_LOWHIGH);\n"
"      case 1:\n"
"         return(STO_CLOSECLOSE);\n"
"      default:\n"
"         return(STO_LOWHIGH);\n"
"     }\n"
"  }\n"
"//+------------------------------------------------------------------+\n"
"enum ALLIGATOR_MODE  { MODE_GATORJAW=1,   MODE_GATORTEETH, MODE_GATORLIPS };\n"
"enum ADX_MODE        { MODE_MAIN,         MODE_PLUSDI, MODE_MINUSDI };\n"
"enum UP_LOW_MODE     { MODE_BASE,         MODE_UPPER,      MODE_LOWER };\n"
"enum ICHIMOKU_MODE   { MODE_TENKANSEN=1,  MODE_KIJUNSEN, MODE_SENKOUSPANA, MODE_SENKOUSPANB, MODE_CHINKOUSPAN };\n"
"enum MAIN_SIGNAL_MODE { MODE_MAIN,         MODE_SIGNAL };\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|MQL4 Buffer wrapper                                               |\n"
"//+------------------------------------------------------------------+\n"
"double CopyBufferMQL4(int handle,int index,int shift)\n"
"  {\n"
"   double buf[];\n"
"   switch(index)\n"
"     {\n"
"      case 0:\n"
"         if(CopyBuffer(handle,0,shift,1,buf)>0)\n"
"            return(buf[0]);\n"
"         break;\n"
"      case 1:\n"
"         if(CopyBuffer(handle,1,shift,1,buf)>0)\n"
"            return(buf[0]);\n"
"         break;\n"
"      case 2:\n"
"         if(CopyBuffer(handle,2,shift,1,buf)>0)\n"
"            return(buf[0]);\n"
"         break;\n"
"      case 3:\n"
"         if(CopyBuffer(handle,3,shift,1,buf)>0)\n"
"            return(buf[0]);\n"
"         break;\n"
"      case 4:\n"
"         if(CopyBuffer(handle,4,shift,1,buf)>0)\n"
"            return(buf[0]);\n"
"         break;\n"
"      default:\n"
"         break;\n"
"     }\n"
"   return(EMPTY_VALUE);\n"
"  }\n"
"\n"
"//+------------------------------------------------------------------+\n"
"//|MQL4 iMA() wrapper                                                |\n"
"//+------------------------------------------------------------------+\n"
"double iMAMQL4(string symbol,\n"
"               int tf,\n"
"               int period,\n"
"               int ma_shift,\n"
"               int method,\n"
"               int price,\n"
"               int shift)\n"
"  {\n"
"   ENUM_TIMEFRAMES timeframe=TFMigrate(tf);\n"
"   ENUM_MA_METHOD ma_method=MethodMigrate(method);\n"
"   ENUM_APPLIED_PRICE applied_price=PriceMigrate(price);\n"
"   int handle=iMA(symbol,timeframe,period,ma_shift,\n"
"                  ma_method,applied_price);\n"
"   if(handle<0)\n"
"     {\n"
"      Print(\"The iMA object is not created: Error\",GetLastError());\n"
"      return(-1);\n"
"     }\n"
"   else\n"
"      return(CopyBufferMQL4(handle,0,shift));\n"
"  }\n"
"//+------------------------------------------------------------------+\n"
"\n";
